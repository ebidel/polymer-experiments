<polymer-element name="polymer-body" extends="body" assetpath="../polymer/">

  <script>

  // upgrade polymer-body last so that it can contain other imported elements
  document.addEventListener('polymer-ready', function() {
    
    Polymer('polymer-body', Platform.mixin({

      created: function() {
        this.template = document.createElement('template');
        var body = wrap(document).body;
        var c$ = body.childNodes.array();
        for (var i=0, c; (c=c$[i]); i++) {
          if (c.localName !== 'script') {
            this.template.content.appendChild(c);
          }
        }
        // snarf up user defined model
        window.model = this;
      },

      parseDeclaration: function(elementElement) {
        this.lightFromTemplate(this.template);
      }

    }, window.model));

  });

  </script>

</polymer-element>
<!--
 Copyright 2013 The Polymer Authors. All rights reserved.
 Use of this source code is governed by a BSD-style
 license that can be found in the LICENSE file.
-->
<script>/**
 * @license
 * Copyright (c) 2012-2014 The Polymer Authors. All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 * 
 *    * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *    * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *    * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
// @version: 0.2.1
Polymer={},"function"==typeof window.Polymer&&(Polymer={}),function(a){function b(a,b){return a&&b&&Object.getOwnPropertyNames(b).forEach(function(c){var d=Object.getOwnPropertyDescriptor(b,c);d&&(Object.defineProperty(a,c,d),"function"==typeof d.value&&(d.value.nom=c))}),a}a.extend=b}(Polymer),function(a){function b(a,b,d){return a?a.stop():a=new c(this),a.go(b,d),a}var c=function(a){this.context=a,this.boundComplete=this.complete.bind(this)};c.prototype={go:function(a,b){this.callback=a;var c;b?(c=setTimeout(this.boundComplete,b),this.handle=function(){clearTimeout(c)}):(c=requestAnimationFrame(this.boundComplete),this.handle=function(){cancelAnimationFrame(c)})},stop:function(){this.handle&&(this.handle(),this.handle=null)},complete:function(){this.handle&&(this.stop(),this.callback.call(this.context))}},a.job=b}(Polymer),function(){var a={};HTMLElement.register=function(b,c){a[b]=c},HTMLElement.getPrototypeForTag=function(b){var c=b?a[b]:HTMLElement.prototype;return c||Object.getPrototypeOf(document.createElement(b))};var b=Event.prototype.stopPropagation;Event.prototype.stopPropagation=function(){this.cancelBubble=!0,b.apply(this,arguments)}}(Polymer),function(a){function b(a){var c=b.caller,g=c.nom,h=c._super;if(h||(g||(g=c.nom=e.call(this,c)),g||console.warn("called super() on a method not installed declaratively (has no .nom property)"),h=d(c,g,f(this))),h){var i=h[g];return i._super||d(i,g,h),i.apply(this,a||[])}}function c(a,b,c){for(;a;){if(a[b]!==c&&a[b])return a;a=f(a)}}function d(a,b,d){return a._super=c(d,b,a),a._super&&(a._super[b].nom=b),a._super}function e(a){for(var b=this.__proto__;b&&b!==HTMLElement.prototype;){for(var c,d=Object.getOwnPropertyNames(b),e=0,f=d.length;f>e&&(c=d[e]);e++){var g=Object.getOwnPropertyDescriptor(b,c);if("function"==typeof g.value&&g.value===a)return c}b=b.__proto__}}function f(a){return a.__proto__}a.super=b}(Polymer),function(a){function b(a,b){var d=typeof b;return b instanceof Date&&(d="date"),c[d](a,b)}var c={string:function(a){return a},date:function(a){return new Date(Date.parse(a)||Date.now())},"boolean":function(a){return""===a?!0:"false"===a?!1:!!a},number:function(a){var b=parseFloat(a);return 0===b&&(b=parseInt(a)),isNaN(b)?a:b},object:function(a,b){if(null===b)return a;try{return JSON.parse(a.replace(/'/g,'"'))}catch(c){return a}},"function":function(a,b){return b}};a.deserializeValue=b}(Polymer),function(a){var b=a.extend,c={};c.declaration={},c.instance={},c.publish=function(a,c){for(var d in a)b(c,a[d])},a.api=c}(Polymer),function(a){var b={async:function(a,b,c){Platform.flush(),b=b&&b.length?b:[b];var d=function(){(this[a]||a).apply(this,b)}.bind(this),e=c?setTimeout(d,c):requestAnimationFrame(d);return c?e:1/e},cancelAsync:function(a){1>a?cancelAnimationFrame(Math.round(1/a)):clearTimeout(a)},fire:function(a,b,c,d,e){var f=c||this,b=b||{},g=new CustomEvent(a,{bubbles:void 0!==d?d:!0,cancelable:void 0!==e?e:!0,detail:b});return f.dispatchEvent(g),g},asyncFire:function(){this.async("fire",arguments)},classFollows:function(a,b,c){b&&b.classList.remove(c),a&&a.classList.add(c)}},c=function(){},d={};b.asyncMethod=b.async,a.api.instance.utils=b,a.nop=c,a.nob=d}(Polymer),function(a){var b=window.logFlags||{},c="on-",d={EVENT_PREFIX:c,addHostListeners:function(){var a=this.eventDelegates;b.events&&Object.keys(a).length>0&&console.log("[%s] addHostListeners:",this.localName,a);var d,e,f=this;for(var g in a)e=c+g,(d=PolymerExpressions.prepareEventBinding(Path.get(a[g]),e,{resolveEventHandler:function(a,b){var c=b.getValueFrom(f);return c?c.bind(f):void 0}}))(this,this,!1)},dispatchMethod:function(a,c,d){if(a){b.events&&console.group("[%s] dispatch [%s]",a.localName,c);var e="function"==typeof c?c:a[c];e&&e[d?"apply":"call"](a,d),b.events&&console.groupEnd(),Platform.flush()}}};a.api.instance.events=d}(Polymer),function(a){var b={copyInstanceAttributes:function(){var a=this._instanceAttributes;for(var b in a)this.hasAttribute(b)||this.setAttribute(b,a[b])},takeAttributes:function(){if(this._publishLC)for(var a,b=0,c=this.attributes,d=c.length;(a=c[b])&&d>b;b++)this.attributeToProperty(a.name,a.value)},attributeToProperty:function(b,c){var b=this.propertyForAttribute(b);if(b){if(c&&c.search(a.bindPattern)>=0)return;var d=this[b],c=this.deserializeValue(c,d);c!==d&&(this[b]=c)}},propertyForAttribute:function(a){var b=this._publishLC&&this._publishLC[a];return b},deserializeValue:function(b,c){return a.deserializeValue(b,c)},serializeValue:function(a,b){return"boolean"===b?a?"":void 0:"object"!==b&&"function"!==b&&void 0!==a?a:void 0},reflectPropertyToAttribute:function(a){var b=typeof this[a],c=this.serializeValue(this[a],b);void 0!==c?this.setAttribute(a,c):"boolean"===b&&this.removeAttribute(a)}};a.api.instance.attributes=b}(Polymer),function(a){function b(a,b,d){c.bind&&console.log(e,inB.localName||"object",inPath,a.localName,b);var f=d.discardChanges();return(null===f||void 0===f)&&d.setValue(a[b]),Observer.defineComputedProperty(a,b,d)}var c=window.logFlags||{},d={observeProperties:function(){var a=this._observeNames,b=this._publishNames;if(a&&a.length||b&&b.length){for(var c,d=this._propertyObserver=new CompoundObserver,e=0,f=a.length;f>e&&(c=a[e]);e++){d.addPath(this,c);var g=Object.getOwnPropertyDescriptor(this.__proto__,c);g&&g.value&&this.observeArrayValue(c,g.value,null)}for(var c,e=0,f=b.length;f>e&&(c=b[e]);e++)this.observe&&void 0!==this.observe[c]||d.addPath(this,c);d.open(this.notifyPropertyChanges,this)}},notifyPropertyChanges:function(a,b,c){var d,e,f={};for(var g in b)d=c[2*g+1],void 0!==this.publish[d]&&this.reflectPropertyToAttribute(d),e=this.observe[d],e&&(this.observeArrayValue(d,a[g],b[g]),f[e]||(f[e]=!0,this.invokeMethod(e,[b[g],a[g],arguments])))},observeArrayValue:function(a,b,d){var e=this.observe[a];if(e&&(Array.isArray(d)&&(c.observe&&console.log("[%s] observeArrayValue: unregister observer [%s]",this.localName,a),this.unregisterObserver(a+"__array")),Array.isArray(b))){c.observe&&console.log("[%s] observeArrayValue: register observer [%s]",this.localName,a,b);var f=new ArrayObserver(b);f.open(function(a,b){this.invokeMethod(e,[b])},this),this.registerObserver(a+"__array",f)}},bindProperty:function(a,c){return b(this,a,c)},unbindAllProperties:function(){this._propertyObserver&&this._propertyObserver.close(),this.unregisterObservers()},unbindProperty:function(a){return this.unregisterObserver(a)},invokeMethod:function(a,b){var c=this[a]||a;"function"==typeof c&&c.apply(this,b)},registerObserver:function(a,b){var c=this._observers||(this._observers={});c[a]=b},unregisterObserver:function(a){var b=this._observers;return b&&b[a]?(b[a].close(),b[a]=null,!0):void 0},unregisterObservers:function(){if(this._observers){for(var a,b,c=Object.keys(this._observers),d=0,e=c.length;e>d&&(a=c[d]);d++)b=this._observers[a],b.close();this._observers={}}}},e="[%s]: bindProperties: [%s] to [%s].[%s]";a.api.instance.properties=d}(Polymer),function(a){function b(a){for(;a.parentNode;){if(a.lightDomController)return a;a=a.parentNode}return a.host}function c(a){e(a,d)}function d(a){a.unbindAll()}function e(a,b){if(a){b(a);for(var c=a.firstChild;c;c=c.nextSibling)e(c,b)}}var f=window.logFlags||0,g=(a.api.instance.events,new PolymerExpressions);g.resolveEventHandler=function(a,c,d){var e=b(d);if(e){var f=c.getValueFrom(e);if(f)return f.bind(e)}};var h={syntax:g,instanceTemplate:function(a){return a.createInstance(this,this.syntax)},bind:function(a,b){this._elementPrepared||this.prepareElement();var c=this.propertyForAttribute(a);if(c){this.unbind(a);var d=this.bindProperty(c,b);return d.path=b.path_,this.reflectPropertyToAttribute(c),this.bindings[a]=d}return this.mixinSuper(arguments)},asyncUnbindAll:function(){this._unbound||(f.unbind&&console.log("[%s] asyncUnbindAll",this.localName),this._unbindAllJob=this.job(this._unbindAllJob,this.unbindAll,0))},unbindAll:function(){if(!this._unbound){this.unbindAllProperties(),this.super();for(var a=this.shadowRoot;a;)c(a),a=a.olderShadowRoot;this._unbound=!0}},cancelUnbindAll:function(a){return this._unbound?void(f.unbind&&console.warn("[%s] already unbound, cannot cancel unbindAll",this.localName)):(f.unbind&&console.log("[%s] cancelUnbindAll",this.localName),this._unbindAllJob&&(this._unbindAllJob=this._unbindAllJob.stop()),void(a||e(this.shadowRoot,function(a){a.cancelUnbindAll&&a.cancelUnbindAll()})))}},i=/\{\{([^{}]*)}}/;a.bindPattern=i,a.api.instance.mdv=h}(Polymer),function(a){function b(a){return a.hasOwnProperty("PolymerBase")}function c(){}var d=0,e={PolymerBase:!0,job:Polymer.job,"super":Polymer.super,created:function(){},ready:function(){},createdCallback:function(){this.created(),(this.ownerDocument.defaultView||this.alwaysPrepare||d>0)&&this.prepareElement()},prepareElement:function(){this._elementPrepared=!0,this.shadowRoots={},this.observeProperties(),this.copyInstanceAttributes(),this.takeAttributes(),this.addHostListeners(),d++,this.parseDeclarations(this.__proto__),d--,this.removeAttribute("unresolved"),this.ready()},attachedCallback:function(){this._elementPrepared||this.prepareElement(),this.cancelUnbindAll(!0),this.attached&&this.attached(),this.enteredView&&this.enteredView(),this.hasBeenAttached||(this.hasBeenAttached=!0,this.domReady&&this.async("domReady"))},detachedCallback:function(){this.preventDispose||this.asyncUnbindAll(),this.detached&&this.detached(),this.leftView&&this.leftView()},enteredViewCallback:function(){this.attachedCallback()},leftViewCallback:function(){this.detachedCallback()},enteredDocumentCallback:function(){this.attachedCallback()},leftDocumentCallback:function(){this.detachedCallback()},parseDeclarations:function(a){a&&a.element&&(this.parseDeclarations(a.__proto__),a.parseDeclaration.call(this,a.element))},parseDeclaration:function(a){var b=this.fetchTemplate(a);if(b){var c=this.shadowFromTemplate(b);this.shadowRoots[a.name]=c}},fetchTemplate:function(a){return a.querySelector("template")},shadowFromTemplate:function(a){if(a){var b=this.createShadowRoot();b.resetStyleInheritance=this.resetStyleInheritance;var c=this.instanceTemplate(a);return b.appendChild(c),this.shadowRootReady(b,a),b}},lightFromTemplate:function(a){if(a){this.lightDomController=!0;var b=this.instanceTemplate(a);return this.appendChild(b),this.shadowRootReady(this,a),b}},shadowRootReady:function(a){this.marshalNodeReferences(a),PointerGestures.register(a)},marshalNodeReferences:function(a){var b=this.$=this.$||{};if(a)for(var c,d=a.querySelectorAll("[id]"),e=0,f=d.length;f>e&&(c=d[e]);e++)b[c.id]=c},attributeChangedCallback:function(a){"class"!==a&&"style"!==a&&this.attributeToProperty(a,this.getAttribute(a)),this.attributeChanged&&this.attributeChanged.apply(this,arguments)},onMutation:function(a,b){var c=new MutationObserver(function(a){b.call(this,c,a),c.disconnect()}.bind(this));c.observe(a,{childList:!0,subtree:!0})}};c.prototype=e,e.constructor=c,a.Base=c,a.isBase=b,a.api.instance.base=e}(Polymer),function(a){function b(a){return a.__proto__}function c(a,b){var c="",d=!1;b&&(c=b.localName,d=b.hasAttribute("is"));var e=Platform.ShadowCSS.makeScopeSelector(c,d);return Platform.ShadowCSS.shimCssText(a,e)}var d=(window.logFlags||{},"element"),e="controller",f={STYLE_SCOPE_ATTRIBUTE:d,installControllerStyles:function(){var a=this.findStyleScope();if(a&&!this.scopeHasNamedStyle(a,this.localName)){for(var c=b(this),d="";c&&c.element;)d+=c.element.cssTextForScope(e),c=b(c);d&&this.installScopeCssText(d,a)}},installScopeStyle:function(a,b){var c=this.findStyleScope(),b=b||"";if(c&&!this.scopeHasNamedStyle(c,this.localName+b)){var d="";if(a instanceof Array)for(var e,f=0,g=a.length;g>f&&(e=a[f]);f++)d+=e.textContent+"\n\n";else d=a.textContent;this.installScopeCssText(d,c,b)}},installScopeCssText:function(a,b,d){if(b=b||this.findStyleScope(),d=d||"",b){window.ShadowDOMPolyfill&&(a=c(a,b.host));var f=this.element.cssTextToScopeStyle(a,e);Polymer.applyStyleToScope(f,b),b._scopeStyles[this.localName+d]=!0}},findStyleScope:function(){for(var a=this;a.parentNode;)a=a.parentNode;return a},scopeHasNamedStyle:function(a,b){return a._scopeStyles=a._scopeStyles||{},a._scopeStyles[b]}};a.api.instance.styles=f}(Polymer),function(a){function b(a,b){if(f[a])throw"Already registered (Polymer) prototype for element "+a;e(a,b),d(a)}function c(a,b){h[a]=b}function d(a){h[a]&&(h[a].registerWhenReady(),delete h[a])}function e(a,b){return i[a]=b||{}}function f(a){return i[a]}var g=a.extend,h=(a.api,{}),i={};a.getRegisteredPrototype=f,a.waitingForPrototype=c,window.Polymer=b,g(Polymer,a);var j=Platform.deliverDeclarations();if(j)for(var k,l=0,m=j.length;m>l&&(k=j[l]);l++)b.apply(null,k)}(Polymer),function(a){var b={resolveElementPaths:function(a){Platform.urlResolver.resolveDom(a)},addResolvePathApi:function(){var a=this.getAttribute("assetpath")||"",b=new URL(a,this.ownerDocument.baseURI);this.prototype.resolvePath=function(a,c){var d=new URL(a,c||b);return d.href}}};a.api.declaration.path=b}(Polymer),function(a){function b(a,b){var c=new URL(a.getAttribute("href"),b).href;return"@import '"+c+"';"}function c(a,b){if(a){b===document&&(b=document.head),window.ShadowDOMPolyfill&&(b=document.head);var c=d(a.textContent),e=a.getAttribute(h);e&&c.setAttribute(h,e),b.appendChild(c)}}function d(a,b){b=b||document,b=b.createElement?b:b.ownerDocument;var c=b.createElement("style");return c.textContent=a,c}function e(a){return a&&a.__resource||""}function f(a,b){return p?p.call(a,b):void 0}var g=(window.logFlags||{},a.api.instance.styles),h=g.STYLE_SCOPE_ATTRIBUTE,i="style",j="@import",k="link[rel=stylesheet]",l="global",m="polymer-scope",n={loadStyles:function(a){var b=this.templateContent();b&&this.convertSheetsToStyles(b);var c=this.findLoadableStyles(b);c.length?Platform.styleResolver.loadStyles(c,a):a&&a()},convertSheetsToStyles:function(a){for(var c,e,f=a.querySelectorAll(k),g=0,h=f.length;h>g&&(c=f[g]);g++)e=d(b(c,this.ownerDocument.baseURI),this.ownerDocument),this.copySheetAttributes(e,c),c.parentNode.replaceChild(e,c)},copySheetAttributes:function(a,b){for(var c,d=0,e=b.attributes,f=e.length;(c=e[d])&&f>d;d++)"rel"!==c.name&&"href"!==c.name&&a.setAttribute(c.name,c.value)},findLoadableStyles:function(a){var b=[];if(a)for(var c,d=a.querySelectorAll(i),e=0,f=d.length;f>e&&(c=d[e]);e++)c.textContent.match(j)&&b.push(c);return b},installSheets:function(){this.cacheSheets(),this.cacheStyles(),this.installLocalSheets(),this.installGlobalStyles()},cacheSheets:function(){this.sheets=this.findNodes(k),this.sheets.forEach(function(a){a.parentNode&&a.parentNode.removeChild(a)})},cacheStyles:function(){this.styles=this.findNodes(i+"["+m+"]"),this.styles.forEach(function(a){a.parentNode&&a.parentNode.removeChild(a)})},installLocalSheets:function(){var a=this.sheets.filter(function(a){return!a.hasAttribute(m)}),b=this.templateContent();if(b){var c="";if(a.forEach(function(a){c+=e(a)+"\n"}),c){var f=d(c,this.ownerDocument);b.insertBefore(f,b.firstChild)}}},findNodes:function(a,b){var c=this.querySelectorAll(a).array(),d=this.templateContent();if(d){var e=d.querySelectorAll(a).array();c=c.concat(e)}return b?c.filter(b):c},templateContent:function(){var a=this.querySelector("template");return a&&templateContent(a)},installGlobalStyles:function(){var a=this.styleForScope(l);c(a,document.head)},cssTextForScope:function(a){var b="",c="["+m+"="+a+"]",d=function(a){return f(a,c)},g=this.sheets.filter(d);g.forEach(function(a){b+=e(a)+"\n\n"});var h=this.styles.filter(d);return h.forEach(function(a){b+=a.textContent+"\n\n"}),b},styleForScope:function(a){var b=this.cssTextForScope(a);return this.cssTextToScopeStyle(b,a)},cssTextToScopeStyle:function(a,b){if(a){var c=d(a);return c.setAttribute(h,this.getAttribute("name")+"-"+b),c}}},o=HTMLElement.prototype,p=o.matches||o.matchesSelector||o.webkitMatchesSelector||o.mozMatchesSelector;a.api.declaration.styles=n,a.applyStyleToScope=c}(Polymer),function(a){var b=(window.logFlags||{},a.api.instance.events),c=b.EVENT_PREFIX,d={parseHostEvents:function(){var a=this.prototype.eventDelegates;this.addAttributeDelegates(a)},addAttributeDelegates:function(a){for(var b,c=0;b=this.attributes[c];c++)this.hasEventPrefix(b.name)&&(a[this.removeEventPrefix(b.name)]=b.value.replace("{{","").replace("}}","").trim())},hasEventPrefix:function(a){return a&&"o"===a[0]&&"n"===a[1]&&"-"===a[2]},removeEventPrefix:function(a){return a.slice(e)}},e=c.length;a.api.declaration.events=d}(Polymer),function(a){var b={inferObservers:function(a){var b,c=a.observe;for(var d in a)"Changed"===d.slice(-7)&&(c||(c=a.observe={}),b=d.slice(0,-7),c[b]=c[b]||d)},explodeObservers:function(a){var b=a.observe;if(b){var c={};for(var d in b)for(var e,f=d.split(" "),g=0;e=f[g];g++)c[e]=b[d];a.observe=c}},optimizePropertyMaps:function(a){if(a.observe){var b=a._observeNames=[];for(var c in a.observe)for(var d,e=c.split(" "),f=0;d=e[f];f++)b.push(d)}if(a.publish){var b=a._publishNames=[];for(var c in a.publish)b.push(c)}},publishProperties:function(a,b){var c=a.publish;c&&(this.requireProperties(c,a,b),a._publishLC=this.lowerCaseMap(c))},requireProperties:function(a,b,c){for(var d in a)void 0===b[d]&&void 0===c[d]&&(b[d]=a[d])},lowerCaseMap:function(a){var b={};for(var c in a)b[c.toLowerCase()]=c;return b}};a.api.declaration.properties=b}(Polymer),function(a){var b="attributes",c=/\s|,/,d={inheritAttributesObjects:function(a){this.inheritObject(a,"publishLC"),this.inheritObject(a,"_instanceAttributes")},publishAttributes:function(a,d){var e=this.getAttribute(b);if(e)for(var f,g=a.publish||(a.publish={}),h=e.split(c),i=0,j=h.length;j>i;i++)f=h[i].trim(),f&&void 0===g[f]&&void 0===d[f]&&(g[f]=null)},accumulateInstanceAttributes:function(){for(var a,b=this.prototype._instanceAttributes,c=this.attributes,d=0,e=c.length;e>d&&(a=c[d]);d++)this.isInstanceAttribute(a.name)&&(b[a.name]=a.value)},isInstanceAttribute:function(a){return!this.blackList[a]&&"on-"!==a.slice(0,3)},blackList:{name:1,"extends":1,constructor:1,noscript:1,assetpath:1,"cache-csstext":1}};d.blackList[b]=1,a.api.declaration.attributes=d}(Polymer),function(a){function b(a){if(!Object.__proto__){var b=Object.getPrototypeOf(a);a.__proto__=b,d(b)&&(b.__proto__=Object.getPrototypeOf(b))}}var c=a.api,d=a.isBase,e=a.extend,f={register:function(a,b){this.buildPrototype(a,b),this.registerPrototype(a,b),this.publishConstructor()},buildPrototype:function(b,c){var d=a.getRegisteredPrototype(b),e=this.generateBasePrototype(c);this.desugarBeforeChaining(d,e),this.prototype=this.chainPrototypes(d,e),this.desugarAfterChaining(b,c)},desugarBeforeChaining:function(a,b){a.element=this,this.publishAttributes(a,b),this.publishProperties(a,b),this.inferObservers(a),this.explodeObservers(a)},chainPrototypes:function(a,c){this.inheritMetaData(a,c);var d=this.chainObject(a,c);return b(d),d},inheritMetaData:function(a,b){this.inheritObject("observe",a,b),this.inheritObject("publish",a,b),this.inheritObject("_publishLC",a,b),this.inheritObject("_instanceAttributes",a,b),this.inheritObject("eventDelegates",a,b)},desugarAfterChaining:function(a,b){this.optimizePropertyMaps(this.prototype),this.installSheets(),this.resolveElementPaths(this),this.accumulateInstanceAttributes(),this.parseHostEvents(),this.addResolvePathApi(),window.ShadowDOMPolyfill&&Platform.ShadowCSS.shimStyling(this.templateContent(),a,b),this.prototype.registerCallback&&this.prototype.registerCallback(this)},publishConstructor:function(){var a=this.getAttribute("constructor");a&&(window[a]=this.ctor)},generateBasePrototype:function(a){var b=this.findBasePrototype(a);if(!b){var b=HTMLElement.getPrototypeForTag(a);b=this.ensureBaseApi(b),g[a]=b}return b},findBasePrototype:function(a){return g[a]},ensureBaseApi:function(a){if(a.PolymerBase)return a;var b=Object.create(a);return c.publish(c.instance,b),this.mixinMethod(b,a,c.instance.mdv,"bind"),b},mixinMethod:function(a,b,c,d){var e=function(a){return b[d].apply(this,a)};a[d]=function(){return this.mixinSuper=e,c[d].apply(this,arguments)}},inheritObject:function(a,b,c){var d=b[a]||{};b[a]=this.chainObject(d,c[a])},registerPrototype:function(a,b){var c={prototype:this.prototype},d=this.findTypeExtension(b);d&&(c.extends=d),HTMLElement.register(a,this.prototype),this.ctor=document.registerElement(a,c)},findTypeExtension:function(a){if(a&&a.indexOf("-")<0)return a;var b=this.findBasePrototype(a);return b.element?this.findTypeExtension(b.element.extends):void 0}},g={};f.chainObject=Object.__proto__?function(a,b){return a&&b&&a!==b&&(a.__proto__=b),a}:function(a,b){if(a&&b&&a!==b){var c=Object.create(b);a=e(c,a)}return a},c.declaration.prototype=f}(Polymer),function(a){function b(a){return document.contains(a)?g:f}function c(){return f.length?f[0]:g[0]}function d(a){e.waitToReady=!0,CustomElements.ready=!1,HTMLImports.whenImportsReady(function(){e.addReadyCallback(a),e.waitToReady=!1,e.check()})}var e={wait:function(a,b,c){return-1===this.indexOf(a)&&(this.add(a),a.__check=b,a.__go=c),0!==this.indexOf(a)},add:function(a){b(a).push(a)},indexOf:function(a){var c=b(a).indexOf(a);return c>=0&&document.contains(a)&&(c+=HTMLImports.useNative||HTMLImports.ready?f.length:1e9),c},go:function(a){var b=this.remove(a);b&&(b.__go.call(b),b.__check=b.__go=null,this.check())},remove:function(a){var c=this.indexOf(a);if(0===c)return b(a).shift()},check:function(){var a=this.nextElement();return a&&a.__check.call(a),this.canReady()?(this.ready(),!0):void 0},nextElement:function(){return c()},canReady:function(){return!this.waitToReady&&this.isEmpty()},isEmpty:function(){return!f.length&&!g.length},ready:function(){if(CustomElements.ready===!1&&(CustomElements.upgradeDocumentTree(document),CustomElements.ready=!0),h)for(var a;h.length;)(a=h.shift())()},addReadyCallback:function(a){a&&h.push(a)},waitToReady:!0},f=[],g=[],h=[];document.addEventListener("WebComponentsReady",function(){CustomElements.ready=!1}),a.queue=e,a.whenPolymerReady=d}(Polymer),function(a){function b(a,b){a?(document.head.appendChild(a),d(b)):b&&b()}function c(a,c){if(a&&a.length){for(var d,e,f=document.createDocumentFragment(),g=0,h=a.length;h>g&&(d=a[g]);g++)e=document.createElement("link"),e.rel="import",e.href=d,f.appendChild(e);b(f,c)}else c&&c()}var d=a.whenPolymerReady;a.import=c,a.importElements=b}(Polymer),function(a){function b(a){return Boolean(HTMLElement.getPrototypeForTag(a))}function c(a){return a&&a.indexOf("-")>=0}var d=a.extend,e=a.api,f=a.queue,g=a.whenPolymerReady,h=a.getRegisteredPrototype,i=a.waitingForPrototype,j=d(Object.create(HTMLElement.prototype),{createdCallback:function(){this.getAttribute("name")&&this.init()},init:function(){this.name=this.getAttribute("name"),this.extends=this.getAttribute("extends"),this.loadResources(),this.registerWhenReady()},registerWhenReady:function(){this.registered||this.waitingForPrototype(this.name)||this.waitingForQueue()||this.waitingForResources()||f.go(this)},_register:function(){c(this.extends)&&!b(this.extends)&&console.warn("%s is attempting to extend %s, an unregistered element or one that was not registered with Polymer.",this.name,this.extends),this.register(this.name,this.extends),this.registered=!0},waitingForPrototype:function(a){return h(a)?void 0:(i(a,this),this.handleNoScript(a),!0)},handleNoScript:function(a){if(this.hasAttribute("noscript")&&!this.noscript)if(this.noscript=!0,window.CustomElements&&!CustomElements.useNative)Polymer(a);else{var b=document.createElement("script");b.textContent="Polymer('"+a+"');",this.appendChild(b)}},waitingForResources:function(){return this._needsResources},waitingForQueue:function(){return f.wait(this,this.registerWhenReady,this._register)},loadResources:function(){this._needsResources=!0,this.loadStyles(function(){this._needsResources=!1,this.registerWhenReady()}.bind(this))}});e.publish(e.declaration,j),a.getRegisteredPrototype=h,g(function(){document.body.removeAttribute("unresolved"),document.dispatchEvent(new CustomEvent("polymer-ready",{bubbles:!0}))}),document.registerElement("polymer-element",{prototype:j})}(Polymer);
//# sourceMappingURL=polymer.js.map</script>
<!-- <link rel="import" href="../polymer-dev/polymer.html"> -->

<!--
Copyright 2013 The Polymer Authors. All rights reserved.
Use of this source code is governed by a BSD-style
license that can be found in the LICENSE file.
-->
<!--
/**
 * @module Polymer Elements
 */
/**
 * polymer-flex-layout provides a helper to use CSS3 Flexible Boxes.  By putting
 * polymer-flex-layout inside an element it makes the element a flex
 * container. Use 'flex' attribute to make the flex item flexible.
 *
 * Example:
 *
 *     <div>
 *       <polymer-flex-layout></polymer-flex-layout>
 *       <div>Left</div>
 *       <div flex>Main</div>
 *       <div>Right</div>
 *     </div>
 *
 *     ---------------------------------
 *     |-------------------------------|
 *     ||Left|       Main       |Right||
 *     |-------------------------------|
 *     ---------------------------------
 *
 *     <div>
 *       <polymer-flex-layout vertical></polymer-flex-layout>
 *       <div>Header</div>
 *       <div flex>Body</div>
 *       <div>Footer</div>
 *     </div>
 *
 *     ----------
 *     ||------||
 *     ||Header||
 *     ||------||
 *     ||Body  ||
 *     ||      ||
 *     ||      ||
 *     ||      ||
 *     ||      ||
 *     ||      ||
 *     ||      ||
 *     ||------||
 *     ||Footer||
 *     ||------||
 *     ----------
 *
 * @class polymer-flex-layout
 */
/**
 * If true, flex items are aligned vertically.
 *
 * @attribute vertical
 * @type boolean
 * @default false
 */
/**
 * Defines the default for how flex items are laid out along the cross axis on 
 * the current line.  Possible values are 'start', 'center' and 'end'.
 *
 * @attribute align
 * @type string
 * @default ''
 */
/**
 * Defines how flex items are laid out along the main axis on the current line.
 * Possible values are 'start', 'center' and 'end'.
 *
 * @attribute justify
 * @type string
 * @default ''
 */
/**
 * If true, polymer-flex-layout is the flex container.
 *
 * Example:
 *
 *     <polymer-flex-layout isContainer>
 *       <div>Left</div>
 *       <div flex>Main</div>
 *       <div>Right</div>
 *     </polymer-flex-layout>
 *
 *     ---------------------------------
 *     |-------------------------------|
 *     ||Left|       Main       |Right||
 *     |-------------------------------|
 *     ---------------------------------
 *
 * @attribute isContainer
 * @type boolean
 * @default false
 */
-->


<polymer-element name="polymer-flex-layout" attributes="vertical align justify isContainer" assetpath="../polymer-flex-layout/">
  <template>
    <style polymer-scope="controller">/*
Copyright 2013 The Polymer Authors. All rights reserved.
Use of this source code is governed by a BSD-style
license that can be found in the LICENSE file.
*/
.flexbox, [flexbox], [h-flexbox], [v-flexbox] {
  display: -webkit-box !important;
  display: -ms-flexbox !important;
  display: -moz-flex !important;
  display: -webkit-flex !important;
  display: flex !important;
}

.flexbox.row, [flexbox], [h-flexbox] {
  -webkit-box-orient: horizontal;
  -ms-flex-direction: row;
  -moz-flex-direction: row;
  -webkit-flex-direction: row;
  flex-direction: row;
}

.flexbox.column, [v-flexbox] {
  -webkit-box-orient: vertical;
  -ms-flex-direction: column;
  -moz-flex-direction: column;
  -webkit-flex-direction: column;
  flex-direction: column;
}

.flex, [flex], [fit] {
  -webkit-box-flex: 1;
  -ms-flex: 1;
  -moz-flex: 1;
  -webkit-flex: 1;
  flex: 1;
}

::content(.flex), 
::content([flex]),
::content([fit]) {
  -webkit-box-flex: 1;
  -ms-flex: 1;
  -moz-flex: 1;
  -webkit-flex: 1;
  flex: 1;
}

.flexbox.align-start {
  -webkit-box-align: start;
  -ms-flex-align: start;
  -moz-align-items: flex-start;
  -webkit-align-items: flex-start;
  align-items: flex-start;
}

.flexbox.align-end {
  -webkit-box-align: end;
  -ms-flex-align: end;
  -moz-align-items: flex-end;
  -webkit-align-items: flex-end;
  align-items: flex-end;
}

.flexbox.align-center {
  -webkit-box-align: center;
  -ms-flex-align: center;
  -moz-align-items: center;
  -webkit-align-items: center;
  align-items: center;
}

.flexbox.justify-start {
  -webkit-box-pack: start;
  -ms-flex-pack: start;
  -moz-justify-content: flex-start;
  -webkit-justify-content: flex-start;
  justify-content: flex-start;
}

.flexbox.justify-end {
  -webkit-box-pack: end;
  -ms-flex-pack: end;
  -moz-justify-content: flex-end;
  -webkit-justify-content: flex-end;
  justify-content: flex-end;
}

.flexbox.justify-center {
  -webkit-box-pack: center;
  -ms-flex-pack: center;
  -moz-justify-content: center;
  -webkit-justify-content: center;
  justify-content: center;
}

.flexbox.justify-between {
  -webkit-box-pack: justify;
  -ms-flex-pack: justify;
  -moz-justify-content: space-between;
  -webkit-justify-content: space-between;
  justify-content: space-between;
}

:host(.flexbox:host, [flexbox]:host, [h-flexbox]:host, [v-flexbox]:host) {
  display: -webkit-box !important;
  display: -ms-flexbox !important;
  display: -moz-flex !important;
  display: -webkit-flex !important;
  display: flex !important;
}
  
:host(.flexbox.row:host, [flexbox]:host, [h-flexbox]:host) {
  -webkit-box-orient: horizontal;
  -ms-flex-direction: row;
  -moz-flex-direction: row;
  -webkit-flex-direction: row;
  flex-direction: row;
}
  
:host(.flexbox.column:host, [v-flexbox]:host) {
  -webkit-box-orient: vertical;
  -ms-flex-direction: column;
  -moz-flex-direction: column;
  -webkit-flex-direction: column;
  flex-direction: column;
}
  
:host(.flexbox.align-start:host) {
  -webkit-box-align: start;
  -ms-flex-align: start;
  -moz-align-items: flex-start;
  -webkit-align-items: flex-start;
  align-items: flex-start;
}
  
:host(.flexbox.align-end:host) {
  -webkit-box-align: end;
  -ms-flex-align: end;
  -moz-align-items: flex-end;
  -webkit-align-items: flex-end;
  align-items: flex-end;
}

:host(.flexbox.align-center:host) {
  -webkit-box-align: center;
  -ms-flex-align: center;
  -moz-align-items: center;
  -webkit-align-items: center;
  align-items: center;
}

:host(.flexbox.justify-start:host) {
  -webkit-box-pack: start;
  -ms-flex-pack: start;
  -moz-justify-content: flex-start;
  -webkit-justify-content: flex-start;
  justify-content: flex-start;
}

:host(.flexbox.justify-end:host) {
  -webkit-box-pack: end;
  -ms-flex-pack: end;
  -moz-justify-content: flex-end;
  -webkit-justify-content: flex-end;
  justify-content: flex-end;
}

:host(.flexbox.justify-center:host) {
  -webkit-box-pack: center;
  -ms-flex-pack: center;
  -moz-justify-content: center;
  -webkit-justify-content: center;
  justify-content: center;
}

:host(.flexbox.justify-between:host) {
  -webkit-box-pack: justify;
  -ms-flex-pack: justify;
  -moz-justify-content: space-between;
  -webkit-justify-content: space-between;
  justify-content: space-between;
}
</style>
    <style>/*
Copyright 2013 The Polymer Authors. All rights reserved.
Use of this source code is governed by a BSD-style
license that can be found in the LICENSE file.
*/
.flexbox, [flexbox], [h-flexbox], [v-flexbox] {
  display: -webkit-box !important;
  display: -ms-flexbox !important;
  display: -moz-flex !important;
  display: -webkit-flex !important;
  display: flex !important;
}

.flexbox.row, [flexbox], [h-flexbox] {
  -webkit-box-orient: horizontal;
  -ms-flex-direction: row;
  -moz-flex-direction: row;
  -webkit-flex-direction: row;
  flex-direction: row;
}

.flexbox.column, [v-flexbox] {
  -webkit-box-orient: vertical;
  -ms-flex-direction: column;
  -moz-flex-direction: column;
  -webkit-flex-direction: column;
  flex-direction: column;
}

.flex, [flex], [fit] {
  -webkit-box-flex: 1;
  -ms-flex: 1;
  -moz-flex: 1;
  -webkit-flex: 1;
  flex: 1;
}

::content(.flex), 
::content([flex]),
::content([fit]) {
  -webkit-box-flex: 1;
  -ms-flex: 1;
  -moz-flex: 1;
  -webkit-flex: 1;
  flex: 1;
}

.flexbox.align-start {
  -webkit-box-align: start;
  -ms-flex-align: start;
  -moz-align-items: flex-start;
  -webkit-align-items: flex-start;
  align-items: flex-start;
}

.flexbox.align-end {
  -webkit-box-align: end;
  -ms-flex-align: end;
  -moz-align-items: flex-end;
  -webkit-align-items: flex-end;
  align-items: flex-end;
}

.flexbox.align-center {
  -webkit-box-align: center;
  -ms-flex-align: center;
  -moz-align-items: center;
  -webkit-align-items: center;
  align-items: center;
}

.flexbox.justify-start {
  -webkit-box-pack: start;
  -ms-flex-pack: start;
  -moz-justify-content: flex-start;
  -webkit-justify-content: flex-start;
  justify-content: flex-start;
}

.flexbox.justify-end {
  -webkit-box-pack: end;
  -ms-flex-pack: end;
  -moz-justify-content: flex-end;
  -webkit-justify-content: flex-end;
  justify-content: flex-end;
}

.flexbox.justify-center {
  -webkit-box-pack: center;
  -ms-flex-pack: center;
  -moz-justify-content: center;
  -webkit-justify-content: center;
  justify-content: center;
}

.flexbox.justify-between {
  -webkit-box-pack: justify;
  -ms-flex-pack: justify;
  -moz-justify-content: space-between;
  -webkit-justify-content: space-between;
  justify-content: space-between;
}

:host(.flexbox:host, [flexbox]:host, [h-flexbox]:host, [v-flexbox]:host) {
  display: -webkit-box !important;
  display: -ms-flexbox !important;
  display: -moz-flex !important;
  display: -webkit-flex !important;
  display: flex !important;
}
  
:host(.flexbox.row:host, [flexbox]:host, [h-flexbox]:host) {
  -webkit-box-orient: horizontal;
  -ms-flex-direction: row;
  -moz-flex-direction: row;
  -webkit-flex-direction: row;
  flex-direction: row;
}
  
:host(.flexbox.column:host, [v-flexbox]:host) {
  -webkit-box-orient: vertical;
  -ms-flex-direction: column;
  -moz-flex-direction: column;
  -webkit-flex-direction: column;
  flex-direction: column;
}
  
:host(.flexbox.align-start:host) {
  -webkit-box-align: start;
  -ms-flex-align: start;
  -moz-align-items: flex-start;
  -webkit-align-items: flex-start;
  align-items: flex-start;
}
  
:host(.flexbox.align-end:host) {
  -webkit-box-align: end;
  -ms-flex-align: end;
  -moz-align-items: flex-end;
  -webkit-align-items: flex-end;
  align-items: flex-end;
}

:host(.flexbox.align-center:host) {
  -webkit-box-align: center;
  -ms-flex-align: center;
  -moz-align-items: center;
  -webkit-align-items: center;
  align-items: center;
}

:host(.flexbox.justify-start:host) {
  -webkit-box-pack: start;
  -ms-flex-pack: start;
  -moz-justify-content: flex-start;
  -webkit-justify-content: flex-start;
  justify-content: flex-start;
}

:host(.flexbox.justify-end:host) {
  -webkit-box-pack: end;
  -ms-flex-pack: end;
  -moz-justify-content: flex-end;
  -webkit-justify-content: flex-end;
  justify-content: flex-end;
}

:host(.flexbox.justify-center:host) {
  -webkit-box-pack: center;
  -ms-flex-pack: center;
  -moz-justify-content: center;
  -webkit-justify-content: center;
  justify-content: center;
}

:host(.flexbox.justify-between:host) {
  -webkit-box-pack: justify;
  -ms-flex-pack: justify;
  -moz-justify-content: space-between;
  -webkit-justify-content: space-between;
  justify-content: space-between;
}
</style>
    <content></content>
  </template>
  <script>
    Polymer('polymer-flex-layout', {
      vertical: false,
      isContainer: false,
      layoutContainer: null,
      enteredView: function() {
        this.installControllerStyles();
        this.layoutContainer = this.isContainer ? 
            this : (this.parentNode.host || this.parentNode);
        this.verticalChanged();
        this.alignChanged();
        this.justifyChanged();
      },
      leftView: function() {
        this.layoutContainer = null;
      },
      layoutContainerChanged: function(old) {
        if (old) {
          old.classList.remove('flexbox');
        }
        this.style.display = this.layoutContainer === this ? '' : 'none';
        if (this.layoutContainer) {
          this.layoutContainer.classList.add('flexbox');
        }
      },
      switchContainerClass: function(prefix, old, name) {
        if (this.layoutContainer && name) {
          this.layoutContainer.classList.switch(
              prefix + old, prefix + name);
        }
      },
      verticalChanged: function() {
        if (this.layoutContainer) {
          this.layoutContainer.classList.toggle('column', this.vertical);
        }
      },
      alignChanged: function(old) {
        this.switchContainerClass('align-', old, this.align);
      },
      justifyChanged: function(old) {
        this.switchContainerClass('justify-', old, this.justify);
      }
    });
  </script>
</polymer-element>



<polymer-element name="polymer-grid-layout" attributes="nodes layout auto" assetpath="../polymer-grid-layout/">
  <template>
  </template>
  <script>
    (function() {
      Polymer('polymer-grid-layout', {
        nodes: null,
        layout: null,
        auto: false,
        created: function() {
          this.layout = [];
        },
        nodesChanged: function() {
          this.invalidate();
        },
        layoutChanged: function() {
          this.invalidate();
        },
        autoNodes: function() {
          this.nodes = this.parentNode.children.array().filter(
            function(node) {
              switch(node.localName) {
                case 'polymer-grid-layout':
                case 'style':
                  return false;
              }
              return true;
            }
          );
        },
        invalidate: function() {
          if (this.layout && this.layout.length) {
            // job debounces layout, only letting it occur every N ms
            this.layoutJob = this.job(this.layoutJob, this.relayout);
          }
        },
        relayout: function() {
          if (!this.nodes || this.auto) {
            this.autoNodes();
          }
          layout(this.layout, this.nodes);
          this.asyncFire('polymer-grid-layout');
        }
      });

      //

      var lineParent;

      function line(axis, p, d) {
        var l = document.createElement('line');
        var extent = (axis === 'left' ? 'width' : 
          (axis === 'top' ? 'height' : axis));
        l.setAttribute('extent', extent);
        if (d < 0) {
          axis = (axis === 'left' ? 'right' : 
            (axis === 'top' ? 'bottom' : axis));
        }
        p = Math.abs(p);
        l.style[axis] = p + 'px';
        l.style[extent] = '0px';
        lineParent.appendChild(l);
      }

      var colCount, colOwners, rowCount, rowOwners;

      function matrixillate(matrix) {
        // mesaure the matrix, must be rectangular
        rowCount = matrix.length;
        colCount = rowCount && matrix[0].length || 0;
        // transpose matrix
        var transpose = [];
        for (var i=0; i<colCount; i++) {
          var c = [];
          for (var j=0; j<rowCount; j++) {
            c.push(matrix[j][i]);
          }
          transpose.push(c);
        }
        // assign sizing control
        colOwners = findOwners(matrix);
        rowOwners = findOwners(transpose);
        //console.log('colOwners', colOwners);
        //console.log('rowOwners', rowOwners);
      }

      function findOwners(matrix) {
        var majCount = matrix.length;
        var minCount = majCount && matrix[0].length || 0;
        var owners = [];
        // for each column (e.g.)
        for (var i=0; i<minCount; i++) {
          // array of contained areas
          var contained = {};
          // look at each row to find a containing area
          for (var j=0; j<majCount; j++) {
            // get the row vector
            var vector = matrix[j]
            // node index at [i,j]
            var nodei = vector[i];
            // if a node is there
            if (nodei) {
              // determine if it bounds this column
              var owns = false;
              if (i === 0) {
                owns = (i === minCount-1) || (nodei !== vector[i+1]);
              } else if (i === minCount - 1) {
                owns = (i === 0) || (nodei !== vector[i-1]);
              } else {
                owns = nodei !== vector[i-1] && nodei !== vector[i+1];
              }
              if (owns) {
                contained[nodei] = 1;
              }
            }
            // store the owners for this column
            owners[i] = contained;
          }
        }
        return owners;
      }

      var nodes;

      function colWidth(i) {
        for (var col in colOwners[i]) {
          col = Number(col);
          if (col === 0) {
            return 96;
          }
          var node = nodes[col - 1];
          if (node.hasAttribute('h-flex') || node.hasAttribute('flex')) {
            return -1;
          }
          var w = node.offsetWidth;
          //console.log('colWidth(' + i + ') ==', w);
          return w;
        }
        return -1;
      }

      function rowHeight(i) {
        for (var row in rowOwners[i]) {
          row = Number(row);
          if (row === 0) {
            return 96;
          }
          var node = nodes[row - 1];
          if (node.hasAttribute('v-flex') || node.hasAttribute('flex')) {
            return -1;
          }
          var h = node.offsetHeight;
          //console.log('rowHeight(' + i + ') ==', h);
          return h;
        }
        return -1;
      }

      var m = 0;

      function railize(count, sizeFn) {
        //
        // create rails for `count` tracks using 
        // sizing function `sizeFn(trackNo)`
        //
        // for n tracks there are (n+1) rails
        //
        //   |track|track|track|
        //  0|->sz0|->sz1|<-sz2|0
        //
        //   |track|track|track|
        //  0|->sz0|     |<-sz2|0
        //
        // there can be one elastic track per set
        //
        //   |track|track|track|track|
        //  0|-->s0|-->s1|<--s1|<--s2|0
        //
        // sz1 spans multiple  tracks which makes
        // it elastic (it's underconstrained)
        //
        var rails = [];
        var a = 0;
        for (var i=0, x; i<count; i++) {
          rails[i] = {p: a, s: 1};
          x = sizeFn(i) + m + m;
          if (x == -1) {
            break;
          }
          a += x;
        }
        if (i === count) {
          rails[i] = {p: 0, s: -1};
        }
        var b = 0;
        for (var ii=count, x; ii>i; ii--) {
          rails[ii] = {p: b, s: -1};
          x = sizeFn(ii - 1) + m + m;
          if (x !== -1) {
            b += x;
          }
        }
        return rails;
      }

      // TODO(sjmiles): this code tries to preserve actual position,
      // so 'unposition' is really 'naturalize' or something
      function unposition(box) {
        var style = box.style;
        //style.right = style.bottom = style.width = style.height = '';
        style.position = 'absolute';
        style.display = 'inline-block';
        style.boxSizing = style.mozBoxSizing = 'border-box';
      }

      function _position(style, maj, min, ext, a, b) {
        style[maj] = style[min] = '';
        style[ext] = 'auto';
        if (a.s < 0 && b.s < 0) {
          var siz = a.p - b.p - m - m;
          style[ext] = siz + 'px';
          var c = 'calc(100% - ' + (b.p + siz + m) + 'px' + ')';
          style[maj] = '-webkit-' + c;
          style[maj] = c;
        } else if (b.s < 0) {
          style[maj] = a.p + m + 'px';
          style[min] = b.p + m + 'px';
        } else {
          style[maj] = a.p + m + 'px';
          style[ext] = b.p - a.p - m - m + 'px';
        }
      }

      function position(elt, left, right, top, bottom) {
        _position(elt.style, 'top', 'bottom', 'height', rows[top], 
            rows[bottom]);
        _position(elt.style, 'left', 'right', 'width', columns[left], 
            columns[right]);
      }

      function layout(matrix, anodes, alineParent) {
        //console.group('layout');

        lineParent = alineParent;
        nodes = anodes;
        matrixillate(matrix);

        nodes.forEach(unposition);

        columns = railize(colCount, colWidth);
        rows = railize(rowCount, rowHeight);

        if (alineParent) {
          //console.group('column rails');
          columns.forEach(function(c) {
            //console.log(c.p, c.s);
            line('left', c.p, c.s);
          });
          //console.groupEnd();

          //console.group('row rails');
          rows.forEach(function(r) {
            //console.log(r.p, r.s);
            line('top', r.p, r.s);
          });
          //console.groupEnd();
        }

        //console.group('rail boundaries');
        nodes.forEach(function(node, i) {
          // node indices are 1-based
          var n = i + 1;
          // boundary rails
          var l, r, t = 1e10, b = -1e10;
          matrix.forEach(function(vector, i) {
            var f = vector.indexOf(n);
            if (f > -1) {
              l = f;
              r = vector.lastIndexOf(n) + 1;
              t = Math.min(t, i);
              b = Math.max(b, i) + 1;
            }
          });
          if (l == undefined) {
            //console.log('unused');
            node.style.position = 'absolute';
            var offscreen = node.getAttribute('offscreen');
            switch (offscreen) {
              case 'basement':
                node.style.zIndex = 0;
                break;
              case 'left':
              case 'top':
                node.style[offscreen] = node.offsetWidth * -2 + 'px';
                break;
              case 'right':
                node.style.left = node.offsetParent.offsetWidth 
                    + node.offsetWidth + 'px';
                break;
              case 'bottom':
                node.style.top = node.parentNode.offsetHeight 
                    + node.offsetHeight + 'px';
                break;
              default:
                node.style[Math.random() >= 0.5 ? 'left' : 'top'] = '-110%';
            }
            //node.style.opacity = 0;
            node.style.pointerEvents = 'none';
          } else {
            node.style.pointerEvents = '';
            //node.style.opacity = '';
            //console.log(l, r, t, b);
            position(node, l, r, t, b);
          }
        });
        //console.groupEnd();
        //console.groupEnd();
      }

    })();
  </script>
</polymer-element>
<!--
Copyright 2013 The Polymer Authors. All rights reserved.
Use of this source code is governed by a BSD-style
license that can be found in the LICENSE file.
-->
<!--
/**
 * @module Polymer Elements
 */
-->
<!--
/**
 * The polymer-selection element is used to manage selection state. It has no
 * visual appearance and is typically used in conjuneciton with another element.
 * For example, <a href="polymer-selector.html">polymer-selector</a>
 * use a polymer-selection to manage selection.
 *
 * To mark an item as selected, call the select(item) method on 
 * polymer-selection. Notice that the item itself is an argument to this method.
 * The polymer-selection element manages selection state for any given set of
 * items. When an item is selected, the `polymer-select` event is fired.
 * The attribute "multi" indicates if multiple items can be selected at once.
 * 
 * Example:
 *
 *     <polymer-element name="selection-example">
 *        <template>
 *          <style>
 *            ::-webkit-distributed(> .selected) {
 *              font-weight: bold;
 *              font-style: italic;
 *            }
 *          </style>
 *          <ul on-tap="{{itemTapAction}}">
 *            <content></content>
 *          </ul>
 *          <polymer-selection id="selection" multi on-polymer-select="{{selectAction}}"></polymer-selection>
 *        </template>
 *        <script>
 *          Polymer('selection-example', {
 *            itemTapAction: function(e) {
 *              this.$.selection.select(e.target);
 *            },
 *            selectAction: function(e, detail) {
 *              detail.item.classList.toggle('selected', detail.isSelected);
 *            }
 *          });
 *        </script>
 *     </polymer-element>
 *
 *     <selection-example>
 *       <li>Red</li>
 *       <li>Green</li>
 *       <li>Blue</li>
 *     </selection-example>
 *
 * @class polymer-selection
 */
 /**
 * Fired when an item's selection state is changed. This event is fired both
 * when an item is selected or deselected. The `isSelected` detail property
 * contains the selection state.
 * 
 * @event polymer-select
 * @param {Object} detail
 *   @param {boolean} detail.isSelected true for selection and false for deselection
 *   @param {Object} detail.item the item element
 */
-->


<polymer-element name="polymer-selection" attributes="multi" assetpath="../polymer-selection/">
  <template>
    <style>
      :host {
        display: none !important;
      }
    </style>
  </template>
  <script>
    Polymer('polymer-selection', {
      /**
       * If true, multiple selections are allowed.
       *
       * @attribute multi
       * @type boolean
       * @default false
       */
      multi: false,
      ready: function() {
        this.clear();
      },
      clear: function() {
        this.selection = [];
      },
      /**
       * Retrieves the selected item(s).
       * @method getSelection
       * @returns Returns the selected item(s). If the multi property is true,
       * getSelection will return an array, otherwise it will return 
       * the selected item or undefined if there is no selection.
      */
      getSelection: function() {
        return this.multi ? this.selection : this.selection[0];
      },
      /**
       * Indicates if a given item is selected.
       * @method isSelected
       * @param {any} item The item whose selection state should be checked.
       * @returns Returns true if `item` is selected.
      */
      isSelected: function(item) {
        return this.selection.indexOf(item) >= 0;
      },
      setItemSelected: function(item, isSelected) {
        if (item !== undefined && item !== null) {
          if (isSelected) {
            this.selection.push(item);
          } else {
            var i = this.selection.indexOf(item);
            if (i >= 0) {
              this.selection.splice(i, 1);
            }
          }
          this.fire("polymer-select", {isSelected: isSelected, item: item});
        }
      },
      /**
       * Set the selection state for a given `item`. If the multi property
       * is true, then the selected state of `item` will be toggled; otherwise
       * the `item` will be selected.
       * @method select
       * @param {any} item: The item to select.
      */
      select: function(item) {
        if (this.multi) {
          this.toggle(item);
        } else if (this.getSelection() !== item) {
          this.setItemSelected(this.getSelection(), false);
          this.setItemSelected(item, true);
        }
      },
      /**
       * Toggles the selection state for `item`.
       * @method toggle
       * @param {any} item: The item to toggle.
      */
      toggle: function(item) {
        this.setItemSelected(item, !this.isSelected(item));
      }
    });
  </script>
</polymer-element>

<!--
Copyright 2013 The Polymer Authors. All rights reserved.
Use of this source code is governed by a BSD-style
license that can be found in the LICENSE file.
-->
<!--
/**
 * @module Polymer Elements
 */
/**
 * polymer-selector is used to manage a list of elements that can be selected.
 * The attribute "selected" indicates which item element is being selected.
 * The attribute "multi" indicates if multiple items can be selected at once.
 * Tapping on the item element would fire "polymer-activate" event. Use
 * "polymer-select" event to listen for selection changes.
 *
 * Example:
 *
 *     <polymer-selector selected="0">
 *       <div>Item 1</div>
 *       <div>Item 2</div>
 *       <div>Item 3</div>
 *     </polymer-selector>
 *
 * polymer-selector is not styled.  So one needs to use "polymer-selected" CSS
 * class to style the selected element.
 * 
 *     <style>
 *       .item.polymer-selected {
 *         background: #eee;
 *       }
 *     </style>
 *     ...
 *     <polymer-selector>
 *       <div class="item">Item 1</div>
 *       <div class="item">Item 2</div>
 *       <div class="item">Item 3</div>
 *     </polymer-selector>
 *
 * @class polymer-selector
 * @status stable
 */
/**
 * Fired when an item's selection state is changed. This event is fired both
 * when an item is selected or deselected. The `isSelected` detail property
 * contains the selection state.
 * 
 * @event polymer-select
 * @param {Object} detail
 *   @param {boolean} detail.isSelected true for selection and false for deselection
 *   @param {Object} detail.item the item element
 */
/**
 * Fired when an item element is tapped.
 * 
 * @event polymer-activate
 * @param {Object} detail
 *   @param {Object} detail.item the item element
 */
-->



<polymer-element name="polymer-selector" attributes="selected multi valueattr selectedClass selectedProperty selectedAttribute selectedItem selectedModel selectedIndex notap target itemsSelector activateEvent" assetpath="../polymer-selector/">
  <template>
    <polymer-selection id="selection" multi="{{multi}}" on-polymer-select="{{selectionSelect}}"></polymer-selection>
    <content id="items" select="*"></content>
  </template>
  <script>
    Polymer('polymer-selector', {
      /**
       * Gets or sets the selected element.  Default to use the index
       * of the item element.
       *
       * If you want a specific attribute value of the element to be
       * used instead of index, set "valueattr" to that attribute name.
       *
       * Example:
       *
       *     <polymer-selector valueattr="label" selected="foo">
       *       <div label="foo"></div>
       *       <div label="bar"></div>
       *       <div label="zot"></div>
       *     </polymer-selector>
       *
       * In multi-selection this should be an array of values.
       *
       * Example:
       *
       *     <polymer-selector id="selector" valueattr="label" multi>
       *       <div label="foo"></div>
       *       <div label="bar"></div>
       *       <div label="zot"></div>
       *     </polymer-selector>
       *
       *     this.$.selector.selected = ['foo', 'zot'];
       *
       * @attribute selected
       * @type Object
       * @default null
       */
      selected: null,
      /**
       * If true, multiple selections are allowed.
       *
       * @attribute multi
       * @type boolean
       * @default false
       */
      multi: false,
      /**
       * Specifies the attribute to be used for "selected" attribute.
       *
       * @attribute valueattr
       * @type string
       * @default 'name'
       */
      valueattr: 'name',
      /**
       * Specifies the CSS class to be used to add to the selected element.
       * 
       * @attribute selectedClass
       * @type string
       * @default 'polymer-selected'
       */
      selectedClass: 'polymer-selected',
      /**
       * Specifies the property to be used to set on the selected element
       * to indicate its active state.
       *
       * @attribute selectedProperty
       * @type string
       * @default ''
       */
      selectedProperty: '',
      /**
       * Specifies the property to be used to set on the selected element
       * to indicate its active state.
       *
       * @attribute selectedProperty
       * @type string
       * @default 'active'
       */
      selectedAttribute: 'active',
      /**
       * Returns the currently selected element. In multi-selection this returns
       * an array of selected elements.
       * 
       * @attribute selectedItem
       * @type Object
       * @default null
       */
      selectedItem: null,
      /**
       * In single selection, this returns the model associated with the
       * selected element.
       * 
       * @attribute selectedModel
       * @type Object
       * @default null
       */
      selectedModel: null,
      /**
       * In single selection, this returns the selected index.
       *
       * @attribute selectedIndex
       * @type number
       * @default -1
       */
      selectedIndex: -1,
      /**
       * The target element that contains items.  If this is not set 
       * polymer-selector is the container.
       * 
       * @attribute target
       * @type Object
       * @default null
       */
      target: null,
      /**
       * This can be used to query nodes from the target node to be used for 
       * selection items.  Note this only works if the 'target' property is set.
       *
       * Example:
       *
       *     <polymer-selector target="{{$.myForm}}" itemsSelector="input[type=radio]"></polymer-selector>
       *     <form id="myForm">
       *       <label><input type="radio" name="color" value="red"> Red</label> <br>
       *       <label><input type="radio" name="color" value="green"> Green</label> <br>
       *       <label><input type="radio" name="color" value="blue"> Blue</label> <br>
       *       <p>color = {{color}}</p>
       *     </form>
       * 
       * @attribute itemSelector
       * @type string
       * @default ''
       */
      itemsSelector: '',
      /**
       * The event that would be fired from the item element to indicate
       * it is being selected.
       *
       * @attribute activateEvent
       * @type string
       * @default 'tap'
       */
      activateEvent: 'tap',
      notap: false,
      ready: function() {
        this.activateListener = this.activateHandler.bind(this);
        this.observer = new MutationObserver(this.updateSelected.bind(this));
        if (!this.target) {
          this.target = this;
        }
      },
      get items() {
        var nodes = this.target !== this ? (this.itemsSelector ? 
            this.target.querySelectorAll(this.itemsSelector) : 
                this.target.children) : this.$.items.getDistributedNodes();
        return Array.prototype.filter.call(nodes || [], function(n) {
          return n && n.localName !== 'template';
        });
      },
      targetChanged: function(old) {
        if (old) {
          this.removeListener(old);
          this.observer.disconnect();
        }
        if (this.target) {
          this.addListener(this.target);
          this.observer.observe(this.target, {childList: true});
        }
      },
      addListener: function(node) {
        node.addEventListener(this.activateEvent, this.activateListener);
      },
      removeListener: function(node) {
        node.removeEventListener(this.activateEvent, this.activateListener);
      },
      get selection() {
        return this.$.selection.getSelection();
      },
      selectedChanged: function() {
        this.updateSelected();
      },
      updateSelected: function() {
        this.validateSelected();
        if (this.multi) {
          this.clearSelection();
          this.selected && this.selected.forEach(function(s) {
            this.valueToSelection(s);
          }, this);
        } else {
          this.valueToSelection(this.selected);
        }
      },
      validateSelected: function() {
        // convert to an array for multi-selection
        if (this.multi && !Array.isArray(this.selected) && 
            this.selected !== null && this.selected !== undefined) {
          this.selected = [this.selected];
        }
      },
      clearSelection: function() {
        if (this.multi) {
          this.selection.slice().forEach(function(s) {
            this.$.selection.setItemSelected(s, false);
          }, this);
        } else {
          this.$.selection.setItemSelected(this.selection, false);
        }
        this.selectedItem = null;
        this.$.selection.clear();
      },
      valueToSelection: function(value) {
        var item = (value === null || value === undefined) ? 
            null : this.items[this.valueToIndex(value)];
        this.$.selection.select(item);
      },
      updateSelectedItem: function() {
        this.selectedItem = this.selection;
      },
      selectedItemChanged: function() {
        if (this.selectedItem) {
          var t = this.selectedItem.templateInstance;
          this.selectedModel = t ? t.model : undefined;
        } else {
          this.selectedModel = null;
        }
        this.selectedIndex = this.selectedItem ? 
            parseInt(this.valueToIndex(this.selected)) : -1;
      },
      valueToIndex: function(value) {
        // find an item with value == value and return it's index
        for (var i=0, items=this.items, c; (c=items[i]); i++) {
          if (this.valueForNode(c) == value) {
            return i;
          }
        }
        // if no item found, the value itself is probably the index
        return value;
      },
      valueForNode: function(node) {
        return node[this.valueattr] || node.getAttribute(this.valueattr);
      },
      // events fired from <polymer-selection> object
      selectionSelect: function(e, detail) {
        this.updateSelectedItem();
        if (detail.item) {
          this.applySelection(detail.item, detail.isSelected);
        }
      },
      applySelection: function(item, isSelected) {
        if (this.selectedClass) {
          item.classList.toggle(this.selectedClass, isSelected);
        }
        if (this.selectedProperty) {
          item[this.selectedProperty] = isSelected;
        }
        if (this.selectedAttribute && item.setAttribute) {
          if (isSelected) {
            item.setAttribute(this.selectedAttribute, '');
          } else {
            item.removeAttribute(this.selectedAttribute);
          }
        }
      },
      // event fired from host
      activateHandler: function(e) {
        if (!this.notap) {
          var i = this.findDistributedTarget(e.target, this.items);
          if (i >= 0) {
            var item = this.items[i];
            var s = this.valueForNode(item) || i;
            if (this.multi) {
              if (this.selected) {
                this.addRemoveSelected(s);
              } else {
                this.selected = [s];
              }
            } else {
              this.selected = s;
            }
            this.asyncFire('polymer-activate', {item: item});
          }
        }
      },
      addRemoveSelected: function(value) {
        var i = this.selected.indexOf(value);
        if (i >= 0) {
          this.selected.splice(i, 1);
        } else {
          this.selected.push(value);
        }
        this.valueToSelection(value);
      },
      findDistributedTarget: function(target, nodes) {
        // find first ancestor of target (including itself) that
        // is in nodes, if any
        while (target && target != this) {
          var i = Array.prototype.indexOf.call(nodes, target);
          if (i >= 0) {
            return i;
          }
          target = target.parentNode;
        }
      }
    });
  </script>
</polymer-element>

<!--
Copyright 2013 The Polymer Authors. All rights reserved.
Use of this source code is governed by a BSD-style
license that can be found in the LICENSE file.
-->


<polymer-element name="polymer-ui-theme-aware" attributes="theme" assetpath="../polymer-ui-theme-aware/">
  <script>
    PolymerUI = {
      validateTheme: function() {
        var theme = this.theme;
        var defaultTheme = this.defaultTheme;
        if (!theme) {
          var p = this;
          while (p && !theme) {
            theme = p.getAttribute && p.getAttribute('theme');
            defaultTheme = defaultTheme || p.defaultTheme;
            p = p.parentNode || p.host;
          }
        }
        this.activeTheme = this.theme || theme || defaultTheme;
      }
    };
    Polymer('polymer-ui-theme-aware', {
      defaultTheme: '',
      activeTheme: '',
      validateTheme: PolymerUI.validateTheme,
      enteredView: function() {
        this.validateTheme();
      },
      themeChanged: function() {
        this.activeTheme = this.theme;
      },
      activeThemeChanged: function(old) {
        this.classList.switch(old, this.activeTheme);
      }
    });
  </script>
</polymer-element>

<!--
Copyright 2013 The Polymer Authors. All rights reserved.
Use of this source code is governed by a BSD-style
license that can be found in the LICENSE file.
-->
<!--
/**
 * @module Polymer UI Elements
 */
/**
 * polymer-ui-menu is a polymer-selector with theme propagation.  It styles to look like 
 * a menu and should be used in conjunction with polymer-ui-menu-item.
 *
 * Example:
 * 
 *     <polymer-ui-menu selected="0">
 *       <polymer-ui-menu-item icon="settings" label="Settings"></polymer-ui-menu-item>
 *       <polymer-ui-menu-item icon="dialog" label="Dialog"></polymer-ui-menu-item>
 *       <polymer-ui-menu-item icon="search" label="Search"></polymer-ui-menu-item>
 *     </polymer-ui-menu>
 *
 * The "selectedItem" property returns the currently selected item.
 *
 * Example:
 *
 *     <polymer-ui-menu selected="0" selectedItem="{{item}}">
 *       <polymer-ui-menu-item icon="settings" label="Settings"></polymer-ui-menu-item>
 *       <polymer-ui-menu-item icon="dialog" label="Dialog"></polymer-ui-menu-item>
 *       <polymer-ui-menu-item icon="search" label="Search"></polymer-ui-menu-item>
 *     </polymer-ui-menu>
 *
 *     <div>selected label: {{item.label}}</div>
 *
 * The event "polymer-select" can also be used to listen for selection change.
 *
 * Example:
 *
 *     <polymer-ui-menu selected="0" on-polymer-select="{{selectAction}}">
 *       <polymer-ui-menu-item icon="settings" label="Settings"></polymer-ui-menu-item>
 *       <polymer-ui-menu-item icon="dialog" label="Dialog"></polymer-ui-menu-item>
 *       <polymer-ui-menu-item icon="search" label="Search"></polymer-ui-menu-item>
 *     </polymer-ui-menu>
 *
 *     ...
 *
 *     selectAction: function(e, detail) {
 *       if (detail.isSelected) {
 *         var selectedItem = detail.item;
 *         ...
 *       }
 *     }
 *
 * @class polymer-ui-menu
 * @extends polymer-selector
 */
-->




<polymer-element name="polymer-ui-menu" extends="polymer-selector" attributes="theme" on-polymer-select="{{selectionChange}}" assetpath="../polymer-ui-menu/">
  <template>
    <style>/*
Copyright 2013 The Polymer Authors. All rights reserved.
Use of this source code is governed by a BSD-style
license that can be found in the LICENSE file.
*/

:host {
  /* technical */
  display: block;
  box-sizing: border-box;
  -moz-box-sizing: border-box;
  /* size */
  padding: 0.4em;
  font-weight: bold;
}

:host(.polymer-ui-light-theme:host) {
  color: #333333;
}

:host(.polymer-ui-dark-theme:host) {
  background: -webkit-linear-gradient(-60deg, #3d3d3d, #353535);
  background: -moz-linear-gradient(-60deg, #3d3d3d, #353535);
  background: -ms-linear-gradient(-60deg, #3d3d3d, #353535);
  color: #ededed;
}
</style>
    <shadow></shadow>
  </template>
  <script>
    Polymer('polymer-ui-menu', {
      activeTheme: '',
      validateTheme: PolymerUI.validateTheme,
      enteredView: function() {
        this.validateTheme();
      },
      themeChanged: function() {
        this.activeTheme = this.theme;
      },
      activeThemeChanged: function(old) {
        this.classList.switch(old, this.activeTheme);
      },
      selectionChange: function(e, detail) {
        if (detail.isSelected) {
          var i = detail.item;
          // find nested selected item
          while (i.selectedItem) {
            i = i.selectedItem;
          }
          this.selectedItem = i;
        }
      }
    });
  </script>
</polymer-element>

<!--
Copyright 2013 The Polymer Authors. All rights reserved.
Use of this source code is governed by a BSD-style
license that can be found in the LICENSE file.
-->
<!--
/**
 * @module Polymer Elements
 */
/**
 * The `polymer-meta` elements provides a method of constructing a 
 * self-organizing database.  It is useful to collate element meta-data for 
 * things like catalogs and for sandbox.
 *
 * Example, an element folder has a `metadata.html` file in it, that contains a 
 * polymer-meta, something like this:
 *
 *     <polymer-meta id="my-element">
 *       <property name="color" type="color"></property>
 *     </polymer-meta>
 *
 * An application can import as many of these files as it wants, and then use 
 * polymer-meta again to access the collected data.
 *
 *     <script>
 *       var meta = document.createElement('polymer-meta');
 *       console.log(meta.list); // dump a list of all meta-data elements that have been created
 *     </script>
 *
 * Use `byId(id)` to retrive a specific polymer-meta.
 *
 *     <script>
 *       var meta = document.createElement('polymer-meta');
 *       console.log(meta.byId('my-element'));
 *     </script>
 *
 * By default all meta-data are stored in a signle databse.  If your meta-data 
 * have different types and want them to be stored separately, use `type` to 
 * differentiate them.
 *
 * @class polymer-meta
 */
-->


<polymer-element name="polymer-meta" attributes="list label type" assetpath="../polymer-meta/">
  <script>
    (function() {
      var SKIP_ID = 'meta';
      var metaData = {}, metaArray = {};

      Polymer('polymer-meta', {
        alwaysPrepare: true,
        /**
         * The type of meta-data.  All meta-data with the same type with be
         * stored together.
         * 
         * @attribute type
         * @type string
         * @default 'default'
         */
        type: 'default',
        ready: function() {
          this.idChanged();
        },
        get metaArray() {
          var t = this.type;
          if (!metaArray[t]) {
            metaArray[t] = [];
          }
          return metaArray[t];
        },
        get metaData() {
          var t = this.type;
          if (!metaData[t]) {
            metaData[t] = {};
          }
          return metaData[t];
        },
        idChanged: function(old) {
          if (this.id && this.id !== SKIP_ID) {
            this.unregister(this, old);
            this.metaData[this.id] = this;
            this.metaArray.push(this);
          }
        },
        unregister: function(meta, id) {
          delete this.metaData[id || meta.id];
          var i = this.metaArray.indexOf(meta);
          if (i >= 0) {
            this.metaArray.splice(i, 1);
          }
        },
        /**
         * Returns a list of all meta-data elements with the same type.
         * 
         * @attribute list
         * @type array
         * @default []
         */
        get list() {
          return this.metaArray;
        },
        /**
         * Returns the first `<template>` in the `<polymer-meta>` subtree. This
         * is useful to store element example.
         *
         *     <polymer-meta id="polymer-ui-toolbar" label="Polymer Toolbar">
         *       <template>
         *         <polymer-ui-toolbar theme="polymer-ui-light-theme">
         *           <polymer-ui-icon-button icon="menu"></polymer-ui-icon-button>
         *           <div flex>Title</div>
         *           <polymer-ui-icon-button icon="add"></polymer-ui-icon-button>
         *         </polymer-ui-toolbar>
         *       </template>
         *     </polymer-meta>
         * 
         * @attribute archetype
         * @type node
         * @default null
         */
        get archetype() {
          return this.querySelector('template');
        },
        /**
         * Retrieves meta-data by ID.
         *
         * @method byId
         * @param {String} id The ID of the meta-data to be returned.
         * @returns Returns meta-data.
         */
        byId: function(id) {
          return this.metaData[id];
        },
        get childMetas() {
          return this.querySelectorAll(this.localName);
        }
      });
    })();
  </script>
</polymer-element>

<!--
Copyright 2013 The Polymer Authors. All rights reserved.
Use of this source code is governed by a BSD-style
license that can be found in the LICENSE file.
-->

<!--
/**
* Polymer UI Elements
*
* @module Polymer UI Elements
*/  
/**
 * polymer-ui-iconset allows users to define their own icon sets.
 *
 * Example:
 *
 *     <polymer-ui-iconset id="my-icons" src="my-icons.png" width="96" iconsize="24"
 *         icons="location place starta stopb bus car train walk">
 *     </polymer-ui-iconset>
 *
 * The above will automatically register the icon set "my-icons" to the iconset
 * database.  To use the user-defined icon set, prefix the icon with
 * the icon set e.g. "my-icons:clock"
 *
 * Example:
 *
 *     <polymer-ui-icon-button icon="my-icons:car"></polymer-ui-icon-button>
 *
 * @class polymer-ui-iconset
 */
-->


<polymer-element name="polymer-ui-iconset" extends="polymer-meta" attributes="src width icons iconsize" assetpath="../polymer-ui-iconset/">
  <script>
    Polymer('polymer-ui-iconset', {
      width: 0,
      icons: '',
      iconsize: 0,
      offsetx: 0,
      offsety: 0,
      type: 'iconset',
      ready: function() {
        // TODO(sorvell): ensure iconset's src is always relative to the main
        // document
        if (this.src && (this.ownerDocument !== document)) {
          this.src = this.resolvePath(this.src, this.ownerDocument.baseURI);
        }
        this.super();
        this.iconsChanged();
        this.updateThemes();
      },
      iconsChanged: function() {
        this.iconMap = {};
        var ox = this.offsetx;
        var oy = this.offsety;
        this.icons && this.icons.split(/\s+/g).forEach(function(name, i) {
          this.iconMap[name] = {
            offsetx: ox,
            offsety: oy
          }
          if (ox + this.iconsize < this.width) {
            ox += this.iconsize;
          } else {
            ox = this.offsetx;
            oy += this.iconsize;
          }
        }, this);
      },
      updateThemes: function() {
        this.themes = {};
        var ts = this.querySelectorAll('property[theme]');
        ts && ts.array().forEach(function(t) {
          this.themes[t.getAttribute('theme')] = {
            offsetx: parseInt(t.getAttribute('offsetx')) || 0,
            offsety: parseInt(t.getAttribute('offsety')) || 0
          };
        }, this);
      },
      // TODO(ffu): support retrived by index e.g. getOffset(10);
      getOffset: function(icon, theme) {
        var i = this.iconMap[icon];
        var t = this.themes[theme];
        if (i && t) {
          return {
            offsetx: i.offsetx + t.offsetx,
            offsety: i.offsety + t.offsety
          }
        }
        return i;
      }
    });
  </script>
</polymer-element>
<!--
Copyright 2013 The Polymer Authors. All rights reserved.
Use of this source code is governed by a BSD-style
license that can be found in the LICENSE file.
-->

<polymer-ui-iconset id="polymer-ui-icons" src="../polymer-ui-action-icons/action-icons.png" width="24" iconsize="24" icons="drawer menu search dropdown close add trash refresh settings dialoga 
           left right down up grid contact account plus time marker 
           briefcase array columns list modules quilt stream maximize shrink sort 
           shortcut dialog twitter facebook favorite gplus filter tag plusone dots">

  <property theme="polymer-ui-light-theme" offsetx="24"></property>
  <property theme="polymer-ui-dark-theme" offsetx="72"></property>
</polymer-ui-iconset>
<!--
Copyright 2013 The Polymer Authors. All rights reserved.
Use of this source code is governed by a BSD-style
license that can be found in the LICENSE file.
-->

<!--
/**
* Polymer UI Elements
*
* @module Polymer UI Elements
*/  
/**
 * polymer-ui-icon is a 24x24 glyph expressed as a background-image.
 *
 * Example:
 *
 *     <polymer-ui-icon src="star.png"></polymer-ui-icon>
 *
 * Optionally can use other size like 32x32 by setting the attribute "size" to "32":
 *
 *     <polymer-ui-icon src="big_star.png" size="32"></polymer-ui-icon>
 *
 * Polymer includes an icon set.  The property "icon" can be used
 * to specify which icon to use.
 *
 * Example:
 *
 *     <polymer-ui-icon icon="menu"></polymer-ui-icon>
 *
 * See <a href="polymer-ui-iconset.html">polymer-ui-iconset</a> on how to use
 * your own icon set.
 *
 * @class polymer-ui-icon
 */
-->





<polymer-element name="polymer-ui-icon" extends="polymer-ui-theme-aware" attributes="src size index icon" assetpath="../polymer-ui-icon/">
  <template>
    <style>/*
Copyright 2013 The Polymer Authors. All rights reserved.
Use of this source code is governed by a BSD-style
license that can be found in the LICENSE file.
*/

:host {
  display: inline-block;
  vertical-align: middle;
  cursor: pointer;
  background-repeat: no-repeat;
}
</style>
    <polymer-ui-iconset id="meta"></polymer-ui-iconset>
    <content></content>
  </template>
  <script>
    Polymer('polymer-ui-icon', {
      /**
       * The URL of an image for the icon.
       *
       * @attribute src
       * @type string
       * @default ''
       */
      src: '',
      /**
       * Specifies the size of the icon.
       *
       * @attribute size
       * @type string
       * @default 24
       */
      size: 24,
      /**
       * Specifies the icon from the icon set.
       *
       * @attribute icon
       * @type string
       * @default ''
       */
      icon: '',
      defaultIconset: 'polymer-ui-icons',
      observe: {
        icon: 'updateIcon',
        activeTheme: 'updateIcon'
      },
      ready: function() {
        this.sizeChanged();
      },
      sizeChanged: function() {
        this.style.width = this.style.height = this.size + 'px';
      },
      srcChanged: function() {
        this.style.backgroundImage = 'url(' + this.src + ')';
        this.style.backgroundPosition = 'center';
        this.style.backgroundSize = this.size + 'px ' + this.size + 'px';
      },
      getIconset: function(name) {
        return this.$.meta.byId(name || this.defaultIconset);
      },
      updateIcon: function() {
        if (!this.icon) {
          return;
        }
        var a = this.icon.split(':');
        var icon = a.pop();
        var n = a.pop();
        var s = this.getIconset(n);
        if (s) {
          var o = s.getOffset(icon, this.activeTheme);
          if (o) {
            var r = this.size / s.iconsize;
            this.style.backgroundImage = 'url(' + s.src + ')';
            this.style.backgroundPosition = 
                (-o.offsetx * r + 'px') + ' ' + (-o.offsety * r + 'px');
            this.style.backgroundSize = r === 1 ? 'auto' : s.width * r + 'px';
          }
        }
      }
    });
  </script>
</polymer-element>

<!--
Copyright 2013 The Toolkitchen Authors. All rights reserved.
Use of this source code is governed by a BSD-style
license that can be found in the LICENSE file.
-->
<!--
/**
 * @module Polymer UI Elements
 */
/**
 * polymer-ui-menu-item is styled to look like a menu item.  It should be used
 * in conjunction with polymer-ui-menu or polymer-ui-sibebar-menu.
 *
 * Example:
 *
 *     <polymer-ui-menu-item icon="settings" label="Settings"></polymer-ui-menu-item>
 *
 * @class polymer-ui-menu-item
 */
/**
 * The URL of an image for the icon.
 *
 * @attribute src
 * @type string
 * @default ''
 */
/**
 * Specifies the icon from the Polymer icon set.
 *
 * @attribute icon
 * @type string
 * @default ''
 */
/**
 * Specifies the label for the menu item.
 *
 * @attribute label
 * @type string
 * @default ''
 */
/**
 * Specifies the URL of the link it goes to when tapped on.
 *
 * Example:
 *
 *     <polymer-ui-menu-item icon="favorite" label="Favorite" href="http://www.polymer-project.org/"></polymer-ui-menu-item>
 *
 * If you want more control on the link, e.g. specify the target for where to
 * open the linked document, you can put &lt;a> directly inside the menu-item.
 *
 * Example:
 *
 *     <polymer-ui-menu-item icon="favorite" label="Favorite">
 *       <a href="http://www.polymer-project.org/" target="_self"></a>
 *     </polymer-ui-menu-item>
 *
 * @attribute href
 * @type string
 * @default ''
 */
-->




<polymer-element name="polymer-ui-menu-item" extends="polymer-ui-theme-aware" attributes="src label icon item href" assetpath="../polymer-ui-menu-item/">
  <template>
    <style>/*
Copyright 2013 The Toolkitchen Authors. All rights reserved.
Use of this source code is governed by a BSD-style
license that can be found in the LICENSE file.
*/

:host { 
  display: block;
  position: relative;
  box-sizing: border-box;
  -moz-box-sizing: border-box;
  height: 40px;
  line-height: 35px;
  font-size: 16px;
  padding: 0 10px;
  border: 1px solid transparent;
  border-radius: 3px;
  white-space: nowrap;
  cursor: pointer;
  opacity: 0.5;
}

:host(:hover:host) {
  opacity: 0.9;
}

:host(.polymer-selected:host, [active]:host) {
  opacity: 1;
}

:host(.polymer-ui-light-theme.polymer-selected:host, .polymer-ui-light-theme[active]:host) {
  background: #f2f2f2;
  border: 1px solid rgba(0, 0, 0, 0.15);
}

:host(.polymer-ui-dark-theme:host) {
  color: #b3b3b3;
}
	
:host(.polymer-ui-dark-theme:hover:host) {
  color: rgba(255, 255, 255, 0.9);
}

:host(.polymer-ui-dark-theme.polymer-selected:host, .polymer-ui-dark-theme[active]:host) {
  background-color: #000;
  border: 1px solid rgba(255, 255, 255, 0.2);
  color: rgba(255, 255, 255, 0.9);
}

:host([active].no-active-bg:host) {
  background-color: transparent;
  border: 1px solid transparent;
}

/* icon and label */
polymer-ui-icon:not([showing]) {
  display: none !important;
}

polymer-ui-icon {
  margin-right: 16px;
}

#label {
  vertical-align: middle;
  padding-right: 20px;
}

/*@polyfill :host #label > a, #link */
::content > a, #link {
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  margin: -1px;
}

#link[hidden] {
  display: none;
}
</style>
    <polymer-ui-icon src="{{src}}" icon="{{icon}}" showing?="{{icon || src}}"></polymer-ui-icon>
    <span id="label">{{label}}<content></content></span>
    <a id="link" href="{{href}}" hidden?="{{!href}}"></a>
  </template>
  <script>
    Polymer('polymer-ui-menu-item', {
      label: '',
      // calc item's offset middle pos instead of using offsetTop/Height 
      // directly which requires to wait for submenu's collapsing transition to 
      // complete first before it can return the correct pos.
      getOffsetMiddle: function() {
        var p = this.parentNode;
        if (p) {
          var i = Array.prototype.indexOf.call(p.items, this);
          var h = this.getItemHeight();
          return i * h + h/2 + p.items[0].offsetTop;
        }
      },
      getItemHeight: function() {
        return this.offsetHeight;
      }
    });
  </script>
</polymer-element>

<!--
Copyright 2013 The Polymer Authors. All rights reserved.
Use of this source code is governed by a BSD-style
license that can be found in the LICENSE file.
-->
<!--
/**
 * @module Polymer Elements
 */
/**
 * polymer-collapse is used to add collapsible behavior to the
 * target element.  It adjusts the height or width of the target element
 * to make the element collapse and expand.
 *
 * Example:
 *
 *     <button on-click="{{toggle}}">toggle collapse</button>
 *     <div id="demo">
 *       ...
 *     </div>
 *     <polymer-collapse id="collapse" targetId="demo"></polymer-collapse>
 *
 *     ...
 *
 *     toggle: function() {
 *       this.$.collapse.toggle();
 *     }
 *
 * @class polymer-collapse
 */
-->


<polymer-element name="polymer-collapse" attributes="targetId target horizontal closed duration fixedSize size" assetpath="../polymer-collapse/">
  <template>
    <style polymer-scope="controller">/*
Copyright 2013 The Polymer Authors. All rights reserved.
Use of this source code is governed by a BSD-style
license that can be found in the LICENSE file.
*/
.polymer-collapse-closed {
  display: none;
}</style>
    <style>/*
Copyright 2013 The Polymer Authors. All rights reserved.
Use of this source code is governed by a BSD-style
license that can be found in the LICENSE file.
*/
.polymer-collapse-closed {
  display: none;
}</style>
    <style>
      :host {
        display: none;
      }
    </style>
  </template>
  <script>
    Polymer('polymer-collapse', {
      /**
       * The id of the target element.
       *
       * @attribute targetId
       * @type string
       * @default ''
       */
      targetId: '',
      /**
       * The target element.
       *
       * @attribute target
       * @type object
       * @default null
       */
      target: null,
      /**
       * If true, the orientation is horizontal; otherwise is vertical.
       *
       * @attribute horizontal
       * @type boolean
       * @default false
       */
      horizontal: false,
      /**
       * If true, the target element is hidden/collapsed.
       *
       * @attribute closed
       * @type boolean
       * @default false
       */
      closed: false,
      /**
       * Collapsing/expanding animation duration in second.
       *
       * @attribute duration
       * @type number
       * @default 0.33
       */
      duration: 0.33,
      /**
       * If true, the size of the target element is fixed and is set
       * on the element.  Otherwise it will try to 
       * use auto to determine the natural size to use
       * for collapsing/expanding.
       *
       * @attribute fixedSize
       * @type boolean
       * @default false
       */
      fixedSize: false,
      size: null,
      attached: function() {
        this.installControllerStyles();
        this.async(function() {
          this.afterInitialUpdate = true;
        });
      },
      detached: function() {
        if (this.target) {
          this.removeListeners(this.target);
        }
      },
      targetIdChanged: function() {
        var p = this.parentNode;
        while (p.parentNode) {
          p = p.parentNode;
        }
        this.target = p.querySelector('#' + this.targetId);
      },
      targetChanged: function(old) {
        if (old) {
          this.removeListeners(old);
        }
        this.horizontalChanged();
        this.isTargetReady = !!this.target;
        if (this.target) {
          this.target.style.overflow = 'hidden';
          this.addListeners(this.target);
          // set polymer-collapse-closed class initially to hide the target
          this.toggleClosedClass(true);
        }
        // don't need to update if the size is already set and it's opened
        if (!this.fixedSize || !this.closed) {
          this.update();
        }
      },
      addListeners: function(node) {
        this.transitionEndListener = this.transitionEndListener || 
            this.transitionEnd.bind(this);
        node.addEventListener('webkitTransitionEnd', this.transitionEndListener);
        node.addEventListener('transitionend', this.transitionEndListener);
      },
      removeListeners: function(node) {
        node.removeEventListener('webkitTransitionEnd', this.transitionEndListener);
        node.removeEventListener('transitionend', this.transitionEndListener);
      },
      horizontalChanged: function() {
        this.dimension = this.horizontal ? 'width' : 'height';
      },
      closedChanged: function() {
        this.update();
      },
      /** 
       * Toggle the closed state of the collapsible.
       *
       * @method toggle
       */
      toggle: function() {
        this.closed = !this.closed;
      },
      setTransitionDuration: function(duration) {
        var s = this.target.style;
        s.webkitTransition = s.transition = duration ? 
            (this.dimension + ' ' + duration + 's') : null;
        if (duration === 0) {
          this.async('transitionEnd');
        }
      },
      transitionEnd: function() {
        if (!this.closed && !this.fixedSize) {
          this.updateSize('auto', null);
        }
        this.setTransitionDuration(null);
        this.toggleClosedClass(this.closed);
      },
      toggleClosedClass: function(add) {
        this.hasClosedClass = add;
        this.target.classList.toggle('polymer-collapse-closed', add);
      },
      updateSize: function(size, duration, forceEnd) {
        if (duration) {
          this.calcSize();
        }
        this.setTransitionDuration(duration);
        var s = this.target.style;
        var nochange = s[this.dimension] === size;
        s[this.dimension] = size;
        // transitonEnd will not be called if the size has not changed
        if (forceEnd && nochange) {
          this.transitionEnd();
        }
      },
      update: function() {
        if (!this.target) {
          return;
        }
        if (!this.isTargetReady) {
          this.targetChanged(); 
        }
        this.horizontalChanged();
        this[this.closed ? 'hide' : 'show']();
      },
      calcSize: function() {
        return this.target.getBoundingClientRect()[this.dimension] + 'px';
      },
      getComputedSize: function() {
        return getComputedStyle(this.target)[this.dimension];
      },
      show: function() {
        this.toggleClosedClass(false);
        // for initial update, skip the expanding animation to optimize
        // performance e.g. skip calcSize
        if (!this.afterInitialUpdate) {
          this.transitionEnd();
          return;
        }
        if (!this.fixedSize) {
          this.updateSize('auto', null);
          var s = this.calcSize();
          this.updateSize(0, null);
        }
        this.async(function() {
          this.updateSize(this.size || s, this.duration, true);
        });
      },
      hide: function() {
        // don't need to do anything if it's already hidden
        if (this.hasClosedClass && !this.fixedSize) {
          return;
        }
        if (this.fixedSize) {
          // save the size before hiding it
          this.size = this.getComputedSize();
        } else {
          this.updateSize(this.calcSize(), null);
        }
        this.async(function() {
          this.updateSize(0, this.duration);
        });
      }
    });
  </script>
</polymer-element>

<!--
Copyright 2013 The Toolkitchen Authors. All rights reserved.
Use of this source code is governed by a BSD-style
license that can be found in the LICENSE file.
-->
<!--
/**
 * @module Polymer UI Elements
 */
/**
 * polymer-ui-submenu-item is a menu-item that can contains other menu-items.
 * It should be used in conjunction with polymer-ui-menu or 
 * polymer-ui-sibebar-menu.
 *
 * Example:
 *
 *     <polymer-ui-menu selected="0">
 *       <polymer-ui-submenu-item icon="settings" label="Topics">
 *         <polymer-ui-menu-item label="Topics 1"></polymer-ui-menu-item>
 *         <polymer-ui-menu-item label="Topics 2"></polymer-ui-menu-item>
 *       </polymer-ui-submenu-item>
 *       <polymer-ui-submenu-item icon="settings" label="Favorites">
 *         <polymer-ui-menu-item label="Favorites 1"></polymer-ui-menu-item>
 *         <polymer-ui-menu-item label="Favorites 2"></polymer-ui-menu-item>
 *         <polymer-ui-menu-item label="Favorites 3"></polymer-ui-menu-item>
 *       </polymer-ui-submenu-item>
 *     </polymer-ui-menu>
 *
 * @class polymer-ui-submenu-item
 * @extends polymer-ui-menu-item
 */
-->






<polymer-element name="polymer-ui-submenu-item" extends="polymer-ui-menu-item" attributes="active selected selectedItem" assetpath="../polymer-ui-submenu-item/">
  <template>
    <style>/*
Copyright 2013 The Toolkitchen Authors. All rights reserved.
Use of this source code is governed by a BSD-style
license that can be found in the LICENSE file.
*/

:host { 
  display: block;
}

/* menu */
#menu {
  margin-left: 44px;
  height: 0;
  /* override :host style on polymer-ui-menu */
  background-image: none !important;
  padding: 0 !important;
}
</style>
    <polymer-ui-menu-item id="item" src="{{src}}" label="{{label}}" icon="{{icon}}" active?="{{active}}" on-tap="{{activate}}">
      <content select=".item-content"></content>
    </polymer-ui-menu-item>
    <polymer-ui-menu id="menu" selected="{{selected}}" selecteditem="{{selectedItem}}">
      <content></content>
    </polymer-ui-menu>
    <polymer-collapse targetid="menu" closed="{{collapsed}}"></polymer-collapse>
  </template>
  <script>
    Polymer('polymer-ui-submenu-item', {
      active: false,
      collapsed: true,
      get items() {
        return this.$.menu.items;
      },
      hasItems: function() {
        return !!this.items.length;
      },
      unselectAllItems: function() {
        this.$.menu.selected = null;
        this.$.menu.clearSelection();
      },
      activeChanged: function() {
        if (this.hasItems()) {
          this.collapsed = !this.active;
        }
        if (!this.active) {
          this.unselectAllItems();
        }
        this.$.item.classList.toggle('no-active-bg', this.hasItems());
      },
      activate: function() {
        if (this.hasItems() && this.active) {
          this.collapsed = !this.collapsed;
          this.unselectAllItems();
          this.fire("polymer-select", {isSelected: true, item: this});
        }
      },
      getItemHeight: function() {
        return this.$ && this.$.item && this.$.item.offsetHeight;
      }
    });
  </script>
</polymer-element>

<!--
Copyright 2013 The Polymer Authors. All rights reserved.
Use of this source code is governed by a BSD-style
license that can be found in the LICENSE file.
-->
<!--
/**
 * @module Polymer Elements
 */
/**
 * polymer-media-query can be used to data bind to a CSS media query.
 * The "query" property is a bare CSS media query.
 * The "queryMatches" property will be a boolean representing if the page matches that media query.
 *
 * polymer-media-query uses media query listeners to dynamically update the "queryMatches" property.
 * A "polymer-mediachange" event also fires when queryMatches changes.
 *
 * Example:
 *
 *      <polymer-media-query query="max-width: 640px" queryMatches="{{phoneScreen}}"></polymer-media-query>
 *
 * @class polymer-media-query
 */
-->


<polymer-element name="polymer-media-query" attributes="query queryMatches" assetpath="../polymer-media-query/">
  <template>
    <style>
      :host {
        display: none;
      }
    </style>
  </template>
  <script>

    Polymer('polymer-media-query', {
      /**
       * The Boolean return value of the media query
       * @attribute queryMatches
       * @type Boolean
       * @default false
       */
      queryMatches: false,
      /**
       * The CSS media query to evaulate
       * @attribute query
       * @type string
       * @default ''
       */
      query: '',
      ready: function() {
        this._mqHandler = this.queryHandler.bind(this);
        this._mq = null;
      },
      queryChanged: function() {
        if (this._mq) {
          this._mq.removeListener(this._mqHandler);
        }
        var query = this.query;
        if (query[0] !== '(') {
          query = '(' + this.query + ')';
        }
        this._mq = window.matchMedia(query);
        this._mq.addListener(this._mqHandler);
        this.queryHandler(this._mq);
      },
      queryHandler: function(mq) {
        this.queryMatches = mq.matches;
        this.asyncFire('polymer-mediachange', mq);
      }
    });
  </script>
</polymer-element>

<!--
Copyright 2013 The Polymer Authors. All rights reserved.
Use of this source code is governed by a BSD-style
license that can be found in the LICENSE file.
-->

<!--
/**
 * @module Polymer UI Elements
 */
/**
 * polymer-ui-toolbar is a horizontal bar containing elements that can perform actions.
 *
 * Example:
 *
 *     <polymer-ui-toolbar>
 *       <polymer-ui-icon-button src="menu.png" on-click="{{menuAction}}"></polymer-ui-icon-button>
 *       <div flex>Title</div>
 *       <polymer-ui-icon-button src="more.png" on-click="{{moreAction}}"></polymer-ui-icon-button>
 *     </polymer-ui-toolbar>
 *
 * polymer-ui-toolbar can adopt to smaller screen size.  If the attribute "responsive" is set
 * and the screen size is less than the responsiveWidth (default to 800px), the toolbar will
 * be moved to the bottom of the page.
 *
 * Example:
 *
 *     <polymer-ui-toolbar>
 *       <polymer-ui-icon-button icon="menu"></polymer-ui-icon-button>
 *       <div flex>Title</div>
 *       <polymer-ui-toolbar responsive>
 *         <polymer-ui-icon-button icon="add"></polymer-ui-icon-button>
 *         <polymer-ui-icon-button icon="trash"></polymer-ui-icon-button>
 *         <polymer-ui-icon-button icon="search"></polymer-ui-icon-button>
 *       </polymer-ui-toolbar>
 *     </polymer-ui-toolbar>
 *
 * @class polymer-ui-toolbar
 */
/**
 * Max-width when element becomes responsive. 
 *
 * @attribute responsiveWidth
 * @type string
 * @default '800px'
 */
-->





<polymer-element name="polymer-ui-toolbar" extends="polymer-ui-theme-aware" attributes="responsiveWidth" assetpath="../polymer-ui-toolbar/">
  <template>
    <style>/*
Copyright 2013 The Polymer Authors. All rights reserved.
Use of this source code is governed by a BSD-style
license that can be found in the LICENSE file.
*/

:host {
  /* technical */
  display: block;
  box-sizing: border-box;
  -moz-box-sizing: border-box;
  /* border/shadow */
	border-bottom: 1px solid rgba(0, 0, 0, 0.15);
	/* size */
  height: 60px;
  font-size: 21px;
	font-family: 'Helvetica Neue Medium', 'HelveticaNeue-Medium', Helvetica, sans-serif;
	position: relative;
}

:host(.polymer-ui-light-theme:host) {
  background: #f2f2f2 -webkit-linear-gradient(top, rgba(197,197,197,0), rgba(197,197,197,0.15));
  background: #f2f2f2 -moz-linear-gradient(top, rgba(197,197,197,0), rgba(197,197,197,0.15));
  background: #f2f2f2 -ms-linear-gradient(top, rgba(197,197,197,0), rgba(197,197,197,0.15));
  color: #333333;
}

:host(.polymer-ui-dark-theme:host) {
  background: #444444 none;
  color: #f3f3f3;
}
  
:host(.narrow-layout[responsive]:host) {
  position: fixed;
  right: 0;
  bottom: 0;
  left: 0;
  z-index: 1;
  border: 0;
  border-top: 1px solid rgba(0, 0, 0, 0.28);
}

/* TODO(sorvell): use of !important due to inability to 
  naturally win over an :host style */
/*@polyfill :host > polymer-ui-icon-button */
::content > polymer-ui-icon-button {
  margin: 0px 8px 0 8px !important;
}

/*@polyfill :host > polymer-ui-menu-button */
::content > polymer-ui-menu-button {
  margin: 0px 8px 0 8px !important;
}

/*@polyfill :host > polymer-ui-toolbar */
::content > polymer-ui-toolbar {
  margin: 0;
}

/*@polyfill :host > polymer-ui-toolbar:not(.narrow-layout) */
::content > polymer-ui-toolbar:not(.narrow-layout) {
  border: 0;
  background: transparent none;
}
</style>
    <polymer-flex-layout align="center"></polymer-flex-layout>
    <polymer-media-query query="max-width: {{responsiveWidth}}" querymatches="{{queryMatches}}"></polymer-media-query>
    <content></content>
  </template>
  <script>
    Polymer('polymer-ui-toolbar', {
      responsiveWidth: '800px',
      queryMatches: false,
      defaultTheme: 'polymer-ui-light-theme',
      queryMatchesChanged: function() {
        this.classList.toggle('narrow-layout', this.queryMatches);
      }
    });
  </script>
</polymer-element>

<!--
Copyright 2013 The Polymer Authors. All rights reserved.
Use of this source code is governed by a BSD-style
license that can be found in the LICENSE file.
-->
<!--
/**
 * @module Polymer UI Elements
 */
/**
 * polymer-ui-icon-button enables you to place an image centered in a button.
 *
 * Example:
 *
 *     <polymer-ui-icon-button src="star.png"></polymer-ui-icon-button>
 *
 * Polymer includes an icon set.  The property "icon" can be used
 * to specify which icon to use.
 *
 * Example:
 *
 *     <polymer-ui-icon-button icon="menu"></polymer-ui-icon-button>
 *
 * @class polymer-ui-icon-button
 */
-->



<polymer-element name="polymer-ui-icon-button" extends="polymer-ui-theme-aware" attributes="src index icon active" assetpath="../polymer-ui-icon-button/">
  <template>
    <style>/*
Copyright 2013 The Polymer Authors. All rights reserved.
Use of this source code is governed by a BSD-style
license that can be found in the LICENSE file.
*/
:host {
  display: inline-block;
  box-sizing: border-box;
  -moz-box-sizing: border-box;
  width: 38px;
  height: 38px;
  background-image: none;
  border-radius: 2px;
  padding: 7px;
  margin: 2px;
  vertical-align: middle;
  cursor: pointer;
}
  
:host(.outline:host) {
  box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.1);
}

:host(:hover:host) {
  box-shadow: 0 1px 0 0 rgba(0, 0, 0, 0.12), 0 0 0 1px rgba(0, 0, 0, 0.1);
}

:host(.selected:host) {
  background-color: rgba(0, 0, 0, 0.05);
  box-shadow: inset 0 1px 0 0 rgba(0, 0, 0, 0.05), 0 0 0 1px rgba(0, 0, 0, 0.12);
}

:host(:active:host, .selected:active:host) {
  background-color: rgba(0, 0, 0, 0.05);
  box-shadow: inset 0 1px 0 0 rgba(0, 0, 0, 0.1), 0 0 0 1px rgba(0, 0, 0, 0.12);
}
  
:host(.polymer-ui-dark-theme.outline:host) {
  background-color: rgba(200, 200, 200, 0.05);
  box-shadow: 0 0 0 1px rgba(200, 200, 200, 0.1);
}

:host(.polymer-ui-dark-theme:hover:host) {
  background-color: rgba(200, 200, 200, 0.05);
  box-shadow: 0 1px 0 0 rgba(200, 200, 200, 0.12), 0 0 0 1px rgba(200, 200, 200, 0.1);
}

:host(.polymer-ui-dark-theme.selected:host) {
  background-color: rgba(220, 220, 220, 0.05);
  box-shadow: inset 0 1px 0 0 rgba(200, 200, 200, 0.05), 0 0 0 1px rgba(200, 200, 200, 0.12);
}

:host(.polymer-ui-dark-theme:active:host, .polymer-ui-dark-theme.selected:active:host) {
  background-color: rgba(200, 200, 200, 0.05);
  box-shadow: inset 0 1px 0 0 rgba(200, 200, 200, 0.1), 0 0 0 1px rgba(200, 200, 200, 0.12);
}

polymer-ui-icon {
  display: block !important;
}</style>
    <polymer-ui-icon src="{{src}}" index="{{index}}" icon="{{icon}}"><content></content></polymer-ui-icon>
  </template>
  <script>
    Polymer('polymer-ui-icon-button', {
      /**
       * The URL of an image for the icon.
       *
       * @attribute src
       * @type string
       * @default ''
       */
      src: '',
      /**
       * If true, border is placed around the button to indicate
       * active state.
       *
       * @attribute active
       * @type boolean
       * @default false
       */
      active: false,
      /**
       * Specifies the icon from the Polymer icon set.
       *
       * @attribute icon
       * @type string
       * @default ''
       */
      icon: '',
      /**
       * If a theme is applied that includes an icon set, the index of the 
       * icon to display.
       *
       * @attribute index
       * @type number
       * @default -1
       */     
      index: -1,
      activeChanged: function() {
        // TODO(sjmiles): sugar this common case
        this.classList.toggle('selected', this.active);
      }
    });
  </script>
</polymer-element>

<!--
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->
<!--
/**
 * @group Polymer Core Elements
 *
 * core-xhr can be used to perform XMLHttpRequests.
 
 * Example:
 *
 *     <core-xhr id="xhr"></core-xhr>
 *     ...
 *     this.$.xhr.request({url: url, params: params, callback: callback});
 *
 * @element core-xhr
 */
-->



<polymer-element name="core-xhr" assetpath="../core-ajax/">

  <template>

    <style>
      :host {
        display: none;
      }
    </style>

  </template>

  <script>

    Polymer('core-xhr', {

      makeReadyStateHandler: function(xhr, callback) {
        xhr.onreadystatechange = function() {
          if (xhr.readyState == 4) {
            callback && callback.call(null, xhr.response, xhr);
          }
        };
      },

      setRequestHeaders: function(xhr, headers) {
        if (headers) {
          for (var name in headers) {
            xhr.setRequestHeader(name, headers[name]);
          }
        }
      },

      toQueryString: function(params) {
        var r = [];
        for (var n in params) {
          var v = params[n];
          n = encodeURIComponent(n);
          r.push(v == null ? n : (n + '=' + encodeURIComponent(v)));
        }
        return r.join('&');
      },

      /**
       * Sends a HTTP request to the server and returns the XHR object.
       *
       * @method request
       * @param {Object} inOptions
       *    @param {String} inOptions.url The url to which the request is sent.
       *    @param {String} inOptions.method The HTTP method to use, default is GET.
       *    @param {boolean} inOptions.sync By default, all requests are sent asynchronously.
       *        To send synchronous requests, set to true.
       *    @param {Object} inOptions.params Data to be sent to the server.
       *    @param {Object} inOptions.body The content for the request body for POST method.
       *    @param {Object} inOptions.headers HTTP request headers.
       *    @param {String} inOptions.responseType The response type. Default is 'text'.
       *    @param {Object} inOptions.callback Called when request is completed.
       * @returns {Object} XHR object.
       */
      request: function(options) {
        var xhr = new XMLHttpRequest();
        var url = options.url;
        var method = options.method || 'GET';
        var async = !options.sync;
        var params = this.toQueryString(options.params);
        if (params && method == 'GET') {
          url += (url.indexOf('?') > 0 ? '&' : '?') + params;
        }
        xhr.open(method, url, async);
        if (options.responseType) {
          xhr.responseType = options.responseType;
        }
        this.makeReadyStateHandler(xhr, options.callback);
        this.setRequestHeaders(xhr, options.headers);
        xhr.send(method == 'POST' ? (options.body || params) : null);
        if (!async) {
          xhr.onreadystatechange(xhr);
        }
        return xhr;
      }

    });

  </script>
  
</polymer-element>

<!--
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->
<!--
/**
 * @group Polymer Core Elements
 *
 * The `core-ajax` element performs `XMLHttpRequest`s.
 * 
 * You can trigger a request explicitly by calling `go` on the
 * element. 
 * 
 * With `auto` set to `true`, the element performs a request whenever
 * its `url` or `params` properties are changed.
 * 
 *
 * Example:
 *
 *     <core-ajax auto url="http://gdata.youtube.com/feeds/api/videos/" 
 *         params='{"alt":"json", "q":"chrome"}'
 *         handleAs="json"
 *         on-core-response="{{handleResponse}}">
 *     </core-ajax>
 * 
 * Note: The `params` attribute must be double quoted JSON.
 *
 * @element core-ajax
 * @status beta
 * @homepage github.io
 *
 */
 
/**
 * Fired when a response is received.
 * 
 * @event core-response
 */
 
/**
 * Fired when an error is received.
 * 
 * @event core-error
 */
 
/**
 * Fired whenever a response or an error is received.
 *
 * @event core-complete
 */
 
-->



<polymer-element name="core-ajax" attributes="url handleAs auto params response method headers body contentType" assetpath="../core-ajax/">

  <script>

    Polymer('core-ajax', {
 
      /**
       * The URL target of the request.
       * 
       * @attribute url
       * @type string
       * @default ''
       */
      url: '',

      /**
       * Specifies what data to store in the `response` property, and
       * to deliver as `event.response` in `response` events.
       * 
       * One of:
       * 
       *    `text`: uses `XHR.responseText`.
       *    
       *    `xml`: uses `XHR.responseXML`.
       *    
       *    `json`: uses `XHR.responseText` parsed as JSON.
       *  
       * @attribute handleAs
       * @type string
       * @default 'text'
       */
      handleAs: '',

      /**
       * If true, automatically performs an Ajax request when either `url` or `params` changes.
       *
       * @attribute auto
       * @type boolean
       * @default false
       */
      auto: false,

      /**
       * Parameters to send to the specified URL, as JSON.
       *  
       * @attribute params
       * @type string (JSON)
       * @default ''
       */
      params: '',

      /**
       * Returns the response object.
       *
       * @attribute response
       * @type Object
       * @default null
       */
      response: null,

      /**
       * The HTTP method to use such as 'GET', 'POST', 'PUT', or 'DELETE'.
       * Default is 'GET'.
       *
       * @attribute method
       * @type string
       * @default ''
       */
      method: '',

      /**
       * HTTP request headers to send.
       *
       * Example:
       *
       *     <core-ajax auto url="http://somesite.com"
       *         headers='{"X-Requested-With": "XMLHttpRequest"}'
       *         handleAs="json"
       *         on-core-response="{{handleResponse}}">
       *     </core-ajax>
       *  
       * @attribute headers
       * @type Object
       * @default null
       */
      headers: null,

      /**
       * Optional raw body content to send when method === "POST".
       *
       * Example:
       *
       *     <core-ajax method="POST" auto url="http://somesite.com"
       *         body='{"foo":1, "bar":2}'>
       *     </core-ajax>
       *  
       * @attribute body
       * @type Object
       * @default null
       */
      body: null,

      /**
       * Content type to use when sending data.
       *
       * @attribute contentType
       * @type string
       * @default 'application/x-www-form-urlencoded'
       */
      contentType: 'application/x-www-form-urlencoded',

      ready: function() {
        this.xhr = document.createElement('core-xhr');
      },

      receive: function(response, xhr) {
        if (this.isSuccess(xhr)) {
          this.processResponse(xhr);
        } else {
          this.error(xhr);
        }
        this.complete(xhr);
      },

      isSuccess: function(xhr) {
        var status = xhr.status || 0;
        return !status || (status >= 200 && status < 300);
      },

      processResponse: function(xhr) {
        var response = this.evalResponse(xhr);
        this.response = response;
        this.fire('core-response', {response: response, xhr: xhr});
      },

      error: function(xhr) {
        var response = xhr.status + ': ' + xhr.responseText;
        this.fire('core-error', {response: response, xhr: xhr});
      },

      complete: function(xhr) {
        this.fire('core-complete', {response: xhr.status, xhr: xhr});
      },

      evalResponse: function(xhr) {
        return this[(this.handleAs || 'text') + 'Handler'](xhr);
      },

      xmlHandler: function(xhr) {
        return xhr.responseXML;
      },

      textHandler: function(xhr) {
        return xhr.responseText;
      },

      jsonHandler: function(xhr) {
        var r = xhr.responseText;
        try {
          return JSON.parse(r);
        } catch (x) {
          return r;
        }
      },

      urlChanged: function() {
        if (!this.handleAs) {
          var ext = String(this.url).split('.').pop();
          switch (ext) {
            case 'json':
              this.handleAs = 'json';
              break;
          }
        }
        this.autoGo();
      },

      paramsChanged: function() {
        this.autoGo();
      },

      autoChanged: function() {
        this.autoGo();
      },

      // TODO(sorvell): multiple side-effects could call autoGo 
      // during one micro-task, use a job to have only one action 
      // occur
      autoGo: function() {
        if (this.auto) {
          this.goJob = this.job(this.goJob, this.go, 0);
        }
      },

      /**
       * Performs an Ajax request to the specified URL.
       *
       * @method go
       */
      go: function() {
        var args = this.xhrArgs || {};
        // TODO(sjmiles): alternatively, we could force POST if body is set
        if (this.method === 'POST') {
          args.body = this.body || args.body;
        }
        args.params = this.params || args.params;
        if (args.params && typeof(args.params) == 'string') {
          args.params = JSON.parse(args.params);
        }
        args.headers = this.headers || args.headers || {};
        if (args.headers && typeof(args.headers) == 'string') {
          args.headers = JSON.parse(args.headers);
        }
        if (this.contentType) {
          args.headers['content-type'] = this.contentType;
        }
        args.callback = this.receive.bind(this);
        args.url = this.url;
        args.method = this.method;
        return args.url && this.xhr.request(args);
      }
      
    });

  </script>

</polymer-element>



<polymer-element name="context-free-parser" attributes="url text data" assetpath="../core-doc-viewer/">

  <template>

    <core-ajax url="{{url}}" response="{{text}}" auto=""></core-ajax>

  </template>

  <script id="test">

    Polymer('context-free-parser', {

      text: null,

      textChanged: function() {

        if (!this.text) {
          //console.log('textChanged:', this.text);
          return;
        }

        var text = this.text;

        var top = {};
        var classes = [];
        var current = top;
        var subCurrent = {};

        function makePragma(object, pragma, content) {
          var p$ = object;
          var p = p$[pragma];
          if (!p) {
            p$[pragma] = p = [];
          }
          p.push(content);
        }

        var js_matches = text.match(/\/\*\*([\s\S]*?)\*\//g) || [];
        text = text.replace(/\/\*\*([\s\S]*?)\*\//g, '');

        var html_matches = text.match(/<!--([\s\S]*?)-->/g) || [];
        var matches = html_matches.concat(js_matches);

        matches.forEach(function(m) {

          var lines = m.replace(/\r\n/g, '\n').replace(/^\s*\/\*\*|^\s*\*\/|^\s*\* ?|^\s*\<\!-\-|^s*\-\-\>/gm, '').split('\n');

          var pragmas = [];
          lines = lines.filter(function(l) {
            var m = l.match(/\s*@([\w-]*) (.*)/);
            if (!m) {
              return true;
            }
            pragmas.push(m);
          });

          var code = lines.join('\n');
          
          pragmas.forEach(function(m) {
            var pragma = m[1], content = m[2];
            switch (pragma) {

              case 'class':
              case 'element':
                current = {
                  name: content,
                  description: code
                };
                classes.push(current);
                break;
              
              case 'attribute':
              case 'method':
              case 'event':
                subCurrent = {
                  name: content,
                  description: code
                };
                makePragma(current, pragma + 's', subCurrent);
                break;

              case 'default':
              case 'type':
                subCurrent[pragma] = content;
                //makePragma(subCurrent, pragma, content);
                break;

              default:
                current[pragma] = content;
                //makePragma(current, pragma, content);
                break;
            }
          });
        });

        if (classes.length === 0) {
          classes.push({name: this.url.split('/').pop(), description: '**Undocumented**'});
        }
        this.data = { classes : classes };
      },

      dataChanged: function() {
        this.fire('data-ready');
      }

    });

  </script>

</polymer-element>

<!--
Copyright 2013 The Polymer Authors. All rights reserved.
Use of this source code is governed by a BSD-style
license that can be found in the LICENSE file.
-->

<script>/**
 * marked - a markdown parser
 * Copyright (c) 2011-2013, Christopher Jeffrey. (MIT Licensed)
 * https://github.com/chjj/marked
 */

;(function() {

/**
 * Block-Level Grammar
 */

var block = {
  newline: /^\n+/,
  code: /^( {4}[^\n]+\n*)+/,
  fences: noop,
  hr: /^( *[-*_]){3,} *(?:\n+|$)/,
  heading: /^ *(#{1,6}) *([^\n]+?) *#* *(?:\n+|$)/,
  nptable: noop,
  lheading: /^([^\n]+)\n *(=|-){2,} *(?:\n+|$)/,
  blockquote: /^( *>[^\n]+(\n[^\n]+)*\n*)+/,
  list: /^( *)(bull) [\s\S]+?(?:hr|\n{2,}(?! )(?!\1bull )\n*|\s*$)/,
  html: /^ *(?:comment|closed|closing) *(?:\n{2,}|\s*$)/,
  def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +["(]([^\n]+)[")])? *(?:\n+|$)/,
  table: noop,
  paragraph: /^((?:[^\n]+\n?(?!hr|heading|lheading|blockquote|tag|def))+)\n*/,
  text: /^[^\n]+/
};

block.bullet = /(?:[*+-]|\d+\.)/;
block.item = /^( *)(bull) [^\n]*(?:\n(?!\1bull )[^\n]*)*/;
block.item = replace(block.item, 'gm')
  (/bull/g, block.bullet)
  ();

block.list = replace(block.list)
  (/bull/g, block.bullet)
  ('hr', /\n+(?=(?: *[-*_]){3,} *(?:\n+|$))/)
  ();

block._tag = '(?!(?:'
  + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code'
  + '|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo'
  + '|span|br|wbr|ins|del|img)\\b)\\w+(?!:/|[^\\w\\s@]*@)\\b';

block.html = replace(block.html)
  ('comment', /<!--[\s\S]*?-->/)
  ('closed', /<(tag)[\s\S]+?<\/\1>/)
  ('closing', /<tag(?:"[^"]*"|'[^']*'|[^'">])*?>/)
  (/tag/g, block._tag)
  ();

block.paragraph = replace(block.paragraph)
  ('hr', block.hr)
  ('heading', block.heading)
  ('lheading', block.lheading)
  ('blockquote', block.blockquote)
  ('tag', '<' + block._tag)
  ('def', block.def)
  ();

/**
 * Normal Block Grammar
 */

block.normal = merge({}, block);

/**
 * GFM Block Grammar
 */

block.gfm = merge({}, block.normal, {
  fences: /^ *(`{3,}|~{3,}) *(\S+)? *\n([\s\S]+?)\s*\1 *(?:\n+|$)/,
  paragraph: /^/
});

block.gfm.paragraph = replace(block.paragraph)
  ('(?!', '(?!'
    + block.gfm.fences.source.replace('\\1', '\\2') + '|'
    + block.list.source.replace('\\1', '\\3') + '|')
  ();

/**
 * GFM + Tables Block Grammar
 */

block.tables = merge({}, block.gfm, {
  nptable: /^ *(\S.*\|.*)\n *([-:]+ *\|[-| :]*)\n((?:.*\|.*(?:\n|$))*)\n*/,
  table: /^ *\|(.+)\n *\|( *[-:]+[-| :]*)\n((?: *\|.*(?:\n|$))*)\n*/
});

/**
 * Block Lexer
 */

function Lexer(options) {
  this.tokens = [];
  this.tokens.links = {};
  this.options = options || marked.defaults;
  this.rules = block.normal;

  if (this.options.gfm) {
    if (this.options.tables) {
      this.rules = block.tables;
    } else {
      this.rules = block.gfm;
    }
  }
}

/**
 * Expose Block Rules
 */

Lexer.rules = block;

/**
 * Static Lex Method
 */

Lexer.lex = function(src, options) {
  var lexer = new Lexer(options);
  return lexer.lex(src);
};

/**
 * Preprocessing
 */

Lexer.prototype.lex = function(src) {
  src = src
    .replace(/\r\n|\r/g, '\n')
    .replace(/\t/g, '    ')
    .replace(/\u00a0/g, ' ')
    .replace(/\u2424/g, '\n');

  return this.token(src, true);
};

/**
 * Lexing
 */

Lexer.prototype.token = function(src, top) {
  var src = src.replace(/^ +$/gm, '')
    , next
    , loose
    , cap
    , bull
    , b
    , item
    , space
    , i
    , l;

  while (src) {
    // newline
    if (cap = this.rules.newline.exec(src)) {
      src = src.substring(cap[0].length);
      if (cap[0].length > 1) {
        this.tokens.push({
          type: 'space'
        });
      }
    }

    // code
    if (cap = this.rules.code.exec(src)) {
      src = src.substring(cap[0].length);
      cap = cap[0].replace(/^ {4}/gm, '');
      this.tokens.push({
        type: 'code',
        text: !this.options.pedantic
          ? cap.replace(/\n+$/, '')
          : cap
      });
      continue;
    }

    // fences (gfm)
    if (cap = this.rules.fences.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'code',
        lang: cap[2],
        text: cap[3]
      });
      continue;
    }

    // heading
    if (cap = this.rules.heading.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'heading',
        depth: cap[1].length,
        text: cap[2]
      });
      continue;
    }

    // table no leading pipe (gfm)
    if (top && (cap = this.rules.nptable.exec(src))) {
      src = src.substring(cap[0].length);

      item = {
        type: 'table',
        header: cap[1].replace(/^ *| *\| *$/g, '').split(/ *\| */),
        align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
        cells: cap[3].replace(/\n$/, '').split('\n')
      };

      for (i = 0; i < item.align.length; i++) {
        if (/^ *-+: *$/.test(item.align[i])) {
          item.align[i] = 'right';
        } else if (/^ *:-+: *$/.test(item.align[i])) {
          item.align[i] = 'center';
        } else if (/^ *:-+ *$/.test(item.align[i])) {
          item.align[i] = 'left';
        } else {
          item.align[i] = null;
        }
      }

      for (i = 0; i < item.cells.length; i++) {
        item.cells[i] = item.cells[i].split(/ *\| */);
      }

      this.tokens.push(item);

      continue;
    }

    // lheading
    if (cap = this.rules.lheading.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'heading',
        depth: cap[2] === '=' ? 1 : 2,
        text: cap[1]
      });
      continue;
    }

    // hr
    if (cap = this.rules.hr.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'hr'
      });
      continue;
    }

    // blockquote
    if (cap = this.rules.blockquote.exec(src)) {
      src = src.substring(cap[0].length);

      this.tokens.push({
        type: 'blockquote_start'
      });

      cap = cap[0].replace(/^ *> ?/gm, '');

      // Pass `top` to keep the current
      // "toplevel" state. This is exactly
      // how markdown.pl works.
      this.token(cap, top);

      this.tokens.push({
        type: 'blockquote_end'
      });

      continue;
    }

    // list
    if (cap = this.rules.list.exec(src)) {
      src = src.substring(cap[0].length);
      bull = cap[2];

      this.tokens.push({
        type: 'list_start',
        ordered: bull.length > 1
      });

      // Get each top-level item.
      cap = cap[0].match(this.rules.item);

      next = false;
      l = cap.length;
      i = 0;

      for (; i < l; i++) {
        item = cap[i];

        // Remove the list item's bullet
        // so it is seen as the next token.
        space = item.length;
        item = item.replace(/^ *([*+-]|\d+\.) +/, '');

        // Outdent whatever the
        // list item contains. Hacky.
        if (~item.indexOf('\n ')) {
          space -= item.length;
          item = !this.options.pedantic
            ? item.replace(new RegExp('^ {1,' + space + '}', 'gm'), '')
            : item.replace(/^ {1,4}/gm, '');
        }

        // Determine whether the next list item belongs here.
        // Backpedal if it does not belong in this list.
        if (this.options.smartLists && i !== l - 1) {
          b = block.bullet.exec(cap[i + 1])[0];
          if (bull !== b && !(bull.length > 1 && b.length > 1)) {
            src = cap.slice(i + 1).join('\n') + src;
            i = l - 1;
          }
        }

        // Determine whether item is loose or not.
        // Use: /(^|\n)(?! )[^\n]+\n\n(?!\s*$)/
        // for discount behavior.
        loose = next || /\n\n(?!\s*$)/.test(item);
        if (i !== l - 1) {
          next = item.charAt(item.length - 1) === '\n';
          if (!loose) loose = next;
        }

        this.tokens.push({
          type: loose
            ? 'loose_item_start'
            : 'list_item_start'
        });

        // Recurse.
        this.token(item, false);

        this.tokens.push({
          type: 'list_item_end'
        });
      }

      this.tokens.push({
        type: 'list_end'
      });

      continue;
    }

    // html
    if (cap = this.rules.html.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: this.options.sanitize
          ? 'paragraph'
          : 'html',
        pre: cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style',
        text: cap[0]
      });
      continue;
    }

    // def
    if (top && (cap = this.rules.def.exec(src))) {
      src = src.substring(cap[0].length);
      this.tokens.links[cap[1].toLowerCase()] = {
        href: cap[2],
        title: cap[3]
      };
      continue;
    }

    // table (gfm)
    if (top && (cap = this.rules.table.exec(src))) {
      src = src.substring(cap[0].length);

      item = {
        type: 'table',
        header: cap[1].replace(/^ *| *\| *$/g, '').split(/ *\| */),
        align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
        cells: cap[3].replace(/(?: *\| *)?\n$/, '').split('\n')
      };

      for (i = 0; i < item.align.length; i++) {
        if (/^ *-+: *$/.test(item.align[i])) {
          item.align[i] = 'right';
        } else if (/^ *:-+: *$/.test(item.align[i])) {
          item.align[i] = 'center';
        } else if (/^ *:-+ *$/.test(item.align[i])) {
          item.align[i] = 'left';
        } else {
          item.align[i] = null;
        }
      }

      for (i = 0; i < item.cells.length; i++) {
        item.cells[i] = item.cells[i]
          .replace(/^ *\| *| *\| *$/g, '')
          .split(/ *\| */);
      }

      this.tokens.push(item);

      continue;
    }

    // top-level paragraph
    if (top && (cap = this.rules.paragraph.exec(src))) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'paragraph',
        text: cap[1].charAt(cap[1].length - 1) === '\n'
          ? cap[1].slice(0, -1)
          : cap[1]
      });
      continue;
    }

    // text
    if (cap = this.rules.text.exec(src)) {
      // Top-level should never reach here.
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'text',
        text: cap[0]
      });
      continue;
    }

    if (src) {
      throw new
        Error('Infinite loop on byte: ' + src.charCodeAt(0));
    }
  }

  return this.tokens;
};

/**
 * Inline-Level Grammar
 */

var inline = {
  escape: /^\\([\\`*{}\[\]()#+\-.!_>])/,
  autolink: /^<([^ >]+(@|:\/)[^ >]+)>/,
  url: noop,
  tag: /^<!--[\s\S]*?-->|^<\/?\w+(?:"[^"]*"|'[^']*'|[^'">])*?>/,
  link: /^!?\[(inside)\]\(href\)/,
  reflink: /^!?\[(inside)\]\s*\[([^\]]*)\]/,
  nolink: /^!?\[((?:\[[^\]]*\]|[^\[\]])*)\]/,
  strong: /^__([\s\S]+?)__(?!_)|^\*\*([\s\S]+?)\*\*(?!\*)/,
  em: /^\b_((?:__|[\s\S])+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,
  code: /^(`+)\s*([\s\S]*?[^`])\s*\1(?!`)/,
  br: /^ {2,}\n(?!\s*$)/,
  del: noop,
  text: /^[\s\S]+?(?=[\\<!\[_*`]| {2,}\n|$)/
};

inline._inside = /(?:\[[^\]]*\]|[^\[\]]|\](?=[^\[]*\]))*/;
inline._href = /\s*<?([\s\S]*?)>?(?:\s+['"]([\s\S]*?)['"])?\s*/;

inline.link = replace(inline.link)
  ('inside', inline._inside)
  ('href', inline._href)
  ();

inline.reflink = replace(inline.reflink)
  ('inside', inline._inside)
  ();

/**
 * Normal Inline Grammar
 */

inline.normal = merge({}, inline);

/**
 * Pedantic Inline Grammar
 */

inline.pedantic = merge({}, inline.normal, {
  strong: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
  em: /^_(?=\S)([\s\S]*?\S)_(?!_)|^\*(?=\S)([\s\S]*?\S)\*(?!\*)/
});

/**
 * GFM Inline Grammar
 */

inline.gfm = merge({}, inline.normal, {
  escape: replace(inline.escape)('])', '~|])')(),
  url: /^(https?:\/\/[^\s<]+[^<.,:;"')\]\s])/,
  del: /^~~(?=\S)([\s\S]*?\S)~~/,
  text: replace(inline.text)
    (']|', '~]|')
    ('|', '|https?://|')
    ()
});

/**
 * GFM + Line Breaks Inline Grammar
 */

inline.breaks = merge({}, inline.gfm, {
  br: replace(inline.br)('{2,}', '*')(),
  text: replace(inline.gfm.text)('{2,}', '*')()
});

/**
 * Inline Lexer & Compiler
 */

function InlineLexer(links, options) {
  this.options = options || marked.defaults;
  this.links = links;
  this.rules = inline.normal;
  this.renderer = this.options.renderer || new Renderer;
  this.renderer.options = this.options;

  if (!this.links) {
    throw new
      Error('Tokens array requires a `links` property.');
  }

  if (this.options.gfm) {
    if (this.options.breaks) {
      this.rules = inline.breaks;
    } else {
      this.rules = inline.gfm;
    }
  } else if (this.options.pedantic) {
    this.rules = inline.pedantic;
  }
}

/**
 * Expose Inline Rules
 */

InlineLexer.rules = inline;

/**
 * Static Lexing/Compiling Method
 */

InlineLexer.output = function(src, links, options) {
  var inline = new InlineLexer(links, options);
  return inline.output(src);
};

/**
 * Lexing/Compiling
 */

InlineLexer.prototype.output = function(src) {
  var out = ''
    , link
    , text
    , href
    , cap;

  while (src) {
    // escape
    if (cap = this.rules.escape.exec(src)) {
      src = src.substring(cap[0].length);
      out += cap[1];
      continue;
    }

    // autolink
    if (cap = this.rules.autolink.exec(src)) {
      src = src.substring(cap[0].length);
      if (cap[2] === '@') {
        text = cap[1].charAt(6) === ':'
          ? this.mangle(cap[1].substring(7))
          : this.mangle(cap[1]);
        href = this.mangle('mailto:') + text;
      } else {
        text = escape(cap[1]);
        href = text;
      }
      out += this.renderer.link(href, null, text);
      continue;
    }

    // url (gfm)
    if (cap = this.rules.url.exec(src)) {
      src = src.substring(cap[0].length);
      text = escape(cap[1]);
      href = text;
      out += this.renderer.link(href, null, text);
      continue;
    }

    // tag
    if (cap = this.rules.tag.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.options.sanitize
        ? escape(cap[0])
        : cap[0];
      continue;
    }

    // link
    if (cap = this.rules.link.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.outputLink(cap, {
        href: cap[2],
        title: cap[3]
      });
      continue;
    }

    // reflink, nolink
    if ((cap = this.rules.reflink.exec(src))
        || (cap = this.rules.nolink.exec(src))) {
      src = src.substring(cap[0].length);
      link = (cap[2] || cap[1]).replace(/\s+/g, ' ');
      link = this.links[link.toLowerCase()];
      if (!link || !link.href) {
        out += cap[0].charAt(0);
        src = cap[0].substring(1) + src;
        continue;
      }
      out += this.outputLink(cap, link);
      continue;
    }

    // strong
    if (cap = this.rules.strong.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.strong(this.output(cap[2] || cap[1]));
      continue;
    }

    // em
    if (cap = this.rules.em.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.em(this.output(cap[2] || cap[1]));
      continue;
    }

    // code
    if (cap = this.rules.code.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.codespan(escape(cap[2], true));
      continue;
    }

    // br
    if (cap = this.rules.br.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.br();
      continue;
    }

    // del (gfm)
    if (cap = this.rules.del.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.del(this.output(cap[1]));
      continue;
    }

    // text
    if (cap = this.rules.text.exec(src)) {
      src = src.substring(cap[0].length);
      out += escape(this.smartypants(cap[0]));
      continue;
    }

    if (src) {
      throw new
        Error('Infinite loop on byte: ' + src.charCodeAt(0));
    }
  }

  return out;
};

/**
 * Compile Link
 */

InlineLexer.prototype.outputLink = function(cap, link) {
  var href = escape(link.href)
    , title = link.title ? escape(link.title) : null;

  return cap[0].charAt(0) !== '!'
    ? this.renderer.link(href, title, this.output(cap[1]))
    : this.renderer.image(href, title, escape(cap[1]));
};

/**
 * Smartypants Transformations
 */

InlineLexer.prototype.smartypants = function(text) {
  if (!this.options.smartypants) return text;
  return text
    // em-dashes
    .replace(/--/g, '\u2014')
    // opening singles
    .replace(/(^|[-\u2014/(\[{"\s])'/g, '$1\u2018')
    // closing singles & apostrophes
    .replace(/'/g, '\u2019')
    // opening doubles
    .replace(/(^|[-\u2014/(\[{\u2018\s])"/g, '$1\u201c')
    // closing doubles
    .replace(/"/g, '\u201d')
    // ellipses
    .replace(/\.{3}/g, '\u2026');
};

/**
 * Mangle Links
 */

InlineLexer.prototype.mangle = function(text) {
  var out = ''
    , l = text.length
    , i = 0
    , ch;

  for (; i < l; i++) {
    ch = text.charCodeAt(i);
    if (Math.random() > 0.5) {
      ch = 'x' + ch.toString(16);
    }
    out += '&#' + ch + ';';
  }

  return out;
};

/**
 * Renderer
 */

function Renderer(options) {
  this.options = options || {};
}

Renderer.prototype.code = function(code, lang, escaped) {
  if (this.options.highlight) {
    var out = this.options.highlight(code, lang);
    if (out != null && out !== code) {
      escaped = true;
      code = out;
    }
  }

  if (!lang) {
    return '<pre><code>'
      + (escaped ? code : escape(code, true))
      + '\n</code></pre>';
  }

  return '<pre><code class="'
    + this.options.langPrefix
    + escape(lang, true)
    + '">'
    + (escaped ? code : escape(code, true))
    + '\n</code></pre>\n';
};

Renderer.prototype.blockquote = function(quote) {
  return '<blockquote>\n' + quote + '</blockquote>\n';
};

Renderer.prototype.html = function(html) {
  return html;
};

Renderer.prototype.heading = function(text, level, raw) {
  return '<h'
    + level
    + ' id="'
    + this.options.headerPrefix
    + raw.toLowerCase().replace(/[^\w]+/g, '-')
    + '">'
    + text
    + '</h'
    + level
    + '>\n';
};

Renderer.prototype.hr = function() {
  return '<hr>\n';
};

Renderer.prototype.list = function(body, ordered) {
  var type = ordered ? 'ol' : 'ul';
  return '<' + type + '>\n' + body + '</' + type + '>\n';
};

Renderer.prototype.listitem = function(text) {
  return '<li>' + text + '</li>\n';
};

Renderer.prototype.paragraph = function(text) {
  return '<p>' + text + '</p>\n';
};

Renderer.prototype.table = function(header, body) {
  return '<table>\n'
    + '<thead>\n'
    + header
    + '</thead>\n'
    + '<tbody>\n'
    + body
    + '</tbody>\n'
    + '</table>\n';
};

Renderer.prototype.tablerow = function(content) {
  return '<tr>\n' + content + '</tr>\n';
};

Renderer.prototype.tablecell = function(content, flags) {
  var type = flags.header ? 'th' : 'td';
  var tag = flags.align
    ? '<' + type + ' style="text-align:' + flags.align + '">'
    : '<' + type + '>';
  return tag + content + '</' + type + '>\n';
};

// span level renderer
Renderer.prototype.strong = function(text) {
  return '<strong>' + text + '</strong>';
};

Renderer.prototype.em = function(text) {
  return '<em>' + text + '</em>';
};

Renderer.prototype.codespan = function(text) {
  return '<code>' + text + '</code>';
};

Renderer.prototype.br = function() {
  return '<br>';
};

Renderer.prototype.del = function(text) {
  return '<del>' + text + '</del>';
};

Renderer.prototype.link = function(href, title, text) {
  if (this.options.sanitize) {
    try {
      var prot = decodeURIComponent(unescape(href))
        .replace(/[^\w:]/g, '')
        .toLowerCase();
    } catch (e) {
      return '';
    }
    if (prot.indexOf('javascript:') === 0) {
      return '';
    }
  }
  var out = '<a href="' + href + '"';
  if (title) {
    out += ' title="' + title + '"';
  }
  out += '>' + text + '</a>';
  return out;
};

Renderer.prototype.image = function(href, title, text) {
  var out = '<img src="' + href + '" alt="' + text + '"';
  if (title) {
    out += ' title="' + title + '"';
  }
  out += '>';
  return out;
};

/**
 * Parsing & Compiling
 */

function Parser(options) {
  this.tokens = [];
  this.token = null;
  this.options = options || marked.defaults;
  this.options.renderer = this.options.renderer || new Renderer;
  this.renderer = this.options.renderer;
  this.renderer.options = this.options;
}

/**
 * Static Parse Method
 */

Parser.parse = function(src, options, renderer) {
  var parser = new Parser(options, renderer);
  return parser.parse(src);
};

/**
 * Parse Loop
 */

Parser.prototype.parse = function(src) {
  this.inline = new InlineLexer(src.links, this.options, this.renderer);
  this.tokens = src.reverse();

  var out = '';
  while (this.next()) {
    out += this.tok();
  }

  return out;
};

/**
 * Next Token
 */

Parser.prototype.next = function() {
  return this.token = this.tokens.pop();
};

/**
 * Preview Next Token
 */

Parser.prototype.peek = function() {
  return this.tokens[this.tokens.length - 1] || 0;
};

/**
 * Parse Text Tokens
 */

Parser.prototype.parseText = function() {
  var body = this.token.text;

  while (this.peek().type === 'text') {
    body += '\n' + this.next().text;
  }

  return this.inline.output(body);
};

/**
 * Parse Current Token
 */

Parser.prototype.tok = function() {
  switch (this.token.type) {
    case 'space': {
      return '';
    }
    case 'hr': {
      return this.renderer.hr();
    }
    case 'heading': {
      return this.renderer.heading(
        this.inline.output(this.token.text),
        this.token.depth,
        this.token.text);
    }
    case 'code': {
      return this.renderer.code(this.token.text,
        this.token.lang,
        this.token.escaped);
    }
    case 'table': {
      var header = ''
        , body = ''
        , i
        , row
        , cell
        , flags
        , j;

      // header
      cell = '';
      for (i = 0; i < this.token.header.length; i++) {
        flags = { header: true, align: this.token.align[i] };
        cell += this.renderer.tablecell(
          this.inline.output(this.token.header[i]),
          { header: true, align: this.token.align[i] }
        );
      }
      header += this.renderer.tablerow(cell);

      for (i = 0; i < this.token.cells.length; i++) {
        row = this.token.cells[i];

        cell = '';
        for (j = 0; j < row.length; j++) {
          cell += this.renderer.tablecell(
            this.inline.output(row[j]),
            { header: false, align: this.token.align[j] }
          );
        }

        body += this.renderer.tablerow(cell);
      }
      return this.renderer.table(header, body);
    }
    case 'blockquote_start': {
      var body = '';

      while (this.next().type !== 'blockquote_end') {
        body += this.tok();
      }

      return this.renderer.blockquote(body);
    }
    case 'list_start': {
      var body = ''
        , ordered = this.token.ordered;

      while (this.next().type !== 'list_end') {
        body += this.tok();
      }

      return this.renderer.list(body, ordered);
    }
    case 'list_item_start': {
      var body = '';

      while (this.next().type !== 'list_item_end') {
        body += this.token.type === 'text'
          ? this.parseText()
          : this.tok();
      }

      return this.renderer.listitem(body);
    }
    case 'loose_item_start': {
      var body = '';

      while (this.next().type !== 'list_item_end') {
        body += this.tok();
      }

      return this.renderer.listitem(body);
    }
    case 'html': {
      var html = !this.token.pre && !this.options.pedantic
        ? this.inline.output(this.token.text)
        : this.token.text;
      return this.renderer.html(html);
    }
    case 'paragraph': {
      return this.renderer.paragraph(this.inline.output(this.token.text));
    }
    case 'text': {
      return this.renderer.paragraph(this.parseText());
    }
  }
};

/**
 * Helpers
 */

function escape(html, encode) {
  return html
    .replace(!encode ? /&(?!#?\w+;)/g : /&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#39;');
}

function unescape(html) {
  return html.replace(/&([#\w]+);/g, function(_, n) {
    n = n.toLowerCase();
    if (n === 'colon') return ':';
    if (n.charAt(0) === '#') {
      return n.charAt(1) === 'x'
        ? String.fromCharCode(parseInt(n.substring(2), 16))
        : String.fromCharCode(+n.substring(1));
    }
    return '';
  });
}

function replace(regex, opt) {
  regex = regex.source;
  opt = opt || '';
  return function self(name, val) {
    if (!name) return new RegExp(regex, opt);
    val = val.source || val;
    val = val.replace(/(^|[^\[])\^/g, '$1');
    regex = regex.replace(name, val);
    return self;
  };
}

function noop() {}
noop.exec = noop;

function merge(obj) {
  var i = 1
    , target
    , key;

  for (; i < arguments.length; i++) {
    target = arguments[i];
    for (key in target) {
      if (Object.prototype.hasOwnProperty.call(target, key)) {
        obj[key] = target[key];
      }
    }
  }

  return obj;
}


/**
 * Marked
 */

function marked(src, opt, callback) {
  if (callback || typeof opt === 'function') {
    if (!callback) {
      callback = opt;
      opt = null;
    }

    opt = merge({}, marked.defaults, opt || {});

    var highlight = opt.highlight
      , tokens
      , pending
      , i = 0;

    try {
      tokens = Lexer.lex(src, opt)
    } catch (e) {
      return callback(e);
    }

    pending = tokens.length;

    var done = function() {
      var out, err;

      try {
        out = Parser.parse(tokens, opt);
      } catch (e) {
        err = e;
      }

      opt.highlight = highlight;

      return err
        ? callback(err)
        : callback(null, out);
    };

    if (!highlight || highlight.length < 3) {
      return done();
    }

    delete opt.highlight;

    if (!pending) return done();

    for (; i < tokens.length; i++) {
      (function(token) {
        if (token.type !== 'code') {
          return --pending || done();
        }
        return highlight(token.text, token.lang, function(err, code) {
          if (code == null || code === token.text) {
            return --pending || done();
          }
          token.text = code;
          token.escaped = true;
          --pending || done();
        });
      })(tokens[i]);
    }

    return;
  }
  try {
    if (opt) opt = merge({}, marked.defaults, opt);
    return Parser.parse(Lexer.lex(src, opt), opt);
  } catch (e) {
    e.message += '\nPlease report this to https://github.com/chjj/marked.';
    if ((opt || marked.defaults).silent) {
      return '<p>An error occured:</p><pre>'
        + escape(e.message + '', true)
        + '</pre>';
    }
    throw e;
  }
}

/**
 * Options
 */

marked.options =
marked.setOptions = function(opt) {
  merge(marked.defaults, opt);
  return marked;
};

marked.defaults = {
  gfm: true,
  tables: true,
  breaks: false,
  pedantic: false,
  sanitize: false,
  smartLists: false,
  silent: false,
  highlight: null,
  langPrefix: 'lang-',
  smartypants: false,
  headerPrefix: '',
  renderer: new Renderer
};

/**
 * Expose
 */

marked.Parser = Parser;
marked.parser = Parser.parse;

marked.Renderer = Renderer;

marked.Lexer = Lexer;
marked.lexer = Lexer.lex;

marked.InlineLexer = InlineLexer;
marked.inlineLexer = InlineLexer.output;

marked.parse = marked;

if (typeof exports === 'object') {
  module.exports = marked;
} else if (typeof define === 'function' && define.amd) {
  define(function() { return marked; });
} else {
  this.marked = marked;
}

}).call(function() {
  return this || (typeof window !== 'undefined' ? window : global);
}());
</script>

<polymer-element name="marked-js" attributes="text" assetpath="../marked-js/">

  <script>
    Polymer('marked-js', {

      text: '',

      enteredView: function() {
        marked.setOptions({
          highlight: this.highlight.bind(this)
        });
        if (!this.text) {
          this.text = this.innerHTML;
        }
      },

      textChanged: function () {
        this.innerHTML = marked(this.text);
      },

      highlight: function(code, lang) {
        var event = this.fire('marked-js-highlight', {code: code, lang: lang});
        return event.detail.code || code;
      }

    });
  </script>

</polymer-element>











<script>var hljs=new function(){function l(o){return o.replace(/&/gm,"&amp;").replace(/</gm,"&lt;").replace(/>/gm,"&gt;")}function b(p){for(var o=p.firstChild;o;o=o.nextSibling){if(o.nodeName=="CODE"){return o}if(!(o.nodeType==3&&o.nodeValue.match(/\s+/))){break}}}function h(p,o){return Array.prototype.map.call(p.childNodes,function(q){if(q.nodeType==3){return o?q.nodeValue.replace(/\n/g,""):q.nodeValue}if(q.nodeName=="BR"){return"\n"}return h(q,o)}).join("")}function a(q){var p=(q.className+" "+q.parentNode.className).split(/\s+/);p=p.map(function(r){return r.replace(/^language-/,"")});for(var o=0;o<p.length;o++){if(e[p[o]]||p[o]=="no-highlight"){return p[o]}}}function c(q){var o=[];(function p(r,s){for(var t=r.firstChild;t;t=t.nextSibling){if(t.nodeType==3){s+=t.nodeValue.length}else{if(t.nodeName=="BR"){s+=1}else{if(t.nodeType==1){o.push({event:"start",offset:s,node:t});s=p(t,s);o.push({event:"stop",offset:s,node:t})}}}}return s})(q,0);return o}function j(x,v,w){var p=0;var y="";var r=[];function t(){if(x.length&&v.length){if(x[0].offset!=v[0].offset){return(x[0].offset<v[0].offset)?x:v}else{return v[0].event=="start"?x:v}}else{return x.length?x:v}}function s(A){function z(B){return" "+B.nodeName+'="'+l(B.value)+'"'}return"<"+A.nodeName+Array.prototype.map.call(A.attributes,z).join("")+">"}while(x.length||v.length){var u=t().splice(0,1)[0];y+=l(w.substr(p,u.offset-p));p=u.offset;if(u.event=="start"){y+=s(u.node);r.push(u.node)}else{if(u.event=="stop"){var o,q=r.length;do{q--;o=r[q];y+=("</"+o.nodeName.toLowerCase()+">")}while(o!=u.node);r.splice(q,1);while(q<r.length){y+=s(r[q]);q++}}}}return y+l(w.substr(p))}function f(q){function o(s,r){return RegExp(s,"m"+(q.cI?"i":"")+(r?"g":""))}function p(y,w){if(y.compiled){return}y.compiled=true;var s=[];if(y.k){var r={};function z(A,t){t.split(" ").forEach(function(B){var C=B.split("|");r[C[0]]=[A,C[1]?Number(C[1]):1];s.push(C[0])})}y.lR=o(y.l||hljs.IR,true);if(typeof y.k=="string"){z("keyword",y.k)}else{for(var x in y.k){if(!y.k.hasOwnProperty(x)){continue}z(x,y.k[x])}}y.k=r}if(w){if(y.bWK){y.b="\\b("+s.join("|")+")\\s"}y.bR=o(y.b?y.b:"\\B|\\b");if(!y.e&&!y.eW){y.e="\\B|\\b"}if(y.e){y.eR=o(y.e)}y.tE=y.e||"";if(y.eW&&w.tE){y.tE+=(y.e?"|":"")+w.tE}}if(y.i){y.iR=o(y.i)}if(y.r===undefined){y.r=1}if(!y.c){y.c=[]}for(var v=0;v<y.c.length;v++){if(y.c[v]=="self"){y.c[v]=y}p(y.c[v],y)}if(y.starts){p(y.starts,w)}var u=[];for(var v=0;v<y.c.length;v++){u.push(y.c[v].b)}if(y.tE){u.push(y.tE)}if(y.i){u.push(y.i)}y.t=u.length?o(u.join("|"),true):{exec:function(t){return null}}}p(q)}function d(D,E){function o(r,M){for(var L=0;L<M.c.length;L++){var K=M.c[L].bR.exec(r);if(K&&K.index==0){return M.c[L]}}}function s(K,r){if(K.e&&K.eR.test(r)){return K}if(K.eW){return s(K.parent,r)}}function t(r,K){return K.i&&K.iR.test(r)}function y(L,r){var K=F.cI?r[0].toLowerCase():r[0];return L.k.hasOwnProperty(K)&&L.k[K]}function G(){var K=l(w);if(!A.k){return K}var r="";var N=0;A.lR.lastIndex=0;var L=A.lR.exec(K);while(L){r+=K.substr(N,L.index-N);var M=y(A,L);if(M){v+=M[1];r+='<span class="'+M[0]+'">'+L[0]+"</span>"}else{r+=L[0]}N=A.lR.lastIndex;L=A.lR.exec(K)}return r+K.substr(N)}function z(){if(A.sL&&!e[A.sL]){return l(w)}var r=A.sL?d(A.sL,w):g(w);if(A.r>0){v+=r.keyword_count;B+=r.r}return'<span class="'+r.language+'">'+r.value+"</span>"}function J(){return A.sL!==undefined?z():G()}function I(L,r){var K=L.cN?'<span class="'+L.cN+'">':"";if(L.rB){x+=K;w=""}else{if(L.eB){x+=l(r)+K;w=""}else{x+=K;w=r}}A=Object.create(L,{parent:{value:A}});B+=L.r}function C(K,r){w+=K;if(r===undefined){x+=J();return 0}var L=o(r,A);if(L){x+=J();I(L,r);return L.rB?0:r.length}var M=s(A,r);if(M){if(!(M.rE||M.eE)){w+=r}x+=J();do{if(A.cN){x+="</span>"}A=A.parent}while(A!=M.parent);if(M.eE){x+=l(r)}w="";if(M.starts){I(M.starts,"")}return M.rE?0:r.length}if(t(r,A)){throw"Illegal"}w+=r;return r.length||1}var F=e[D];f(F);var A=F;var w="";var B=0;var v=0;var x="";try{var u,q,p=0;while(true){A.t.lastIndex=p;u=A.t.exec(E);if(!u){break}q=C(E.substr(p,u.index-p),u[0]);p=u.index+q}C(E.substr(p));return{r:B,keyword_count:v,value:x,language:D}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:l(E)}}else{throw H}}}function g(s){var o={keyword_count:0,r:0,value:l(s)};var q=o;for(var p in e){if(!e.hasOwnProperty(p)){continue}var r=d(p,s);r.language=p;if(r.keyword_count+r.r>q.keyword_count+q.r){q=r}if(r.keyword_count+r.r>o.keyword_count+o.r){q=o;o=r}}if(q.language){o.second_best=q}return o}function i(q,p,o){if(p){q=q.replace(/^((<[^>]+>|\t)+)/gm,function(r,v,u,t){return v.replace(/\t/g,p)})}if(o){q=q.replace(/\n/g,"<br>")}return q}function m(r,u,p){var v=h(r,p);var t=a(r);if(t=="no-highlight"){return}var w=t?d(t,v):g(v);t=w.language;var o=c(r);if(o.length){var q=document.createElement("pre");q.innerHTML=w.value;w.value=j(o,c(q),v)}w.value=i(w.value,u,p);var s=r.className;if(!s.match("(\\s|^)(language-)?"+t+"(\\s|$)")){s=s?(s+" "+t):t}r.innerHTML=w.value;r.className=s;r.result={language:t,kw:w.keyword_count,re:w.r};if(w.second_best){r.second_best={language:w.second_best.language,kw:w.second_best.keyword_count,re:w.second_best.r}}}function n(){if(n.called){return}n.called=true;Array.prototype.map.call(document.getElementsByTagName("pre"),b).filter(Boolean).forEach(function(o){m(o,hljs.tabReplace)})}function k(){window.addEventListener("DOMContentLoaded",n,false);window.addEventListener("load",n,false)}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=m;this.initHighlighting=n;this.initHighlightingOnLoad=k;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.BE={b:"\\\\[\\s\\S]",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(q,r){var o={};for(var p in q){o[p]=q[p]}if(r){for(var p in r){o[p]=r[p]}}return o}}();hljs.LANGUAGES.javascript=function(a){return{k:{keyword:"in if for while finally var new function do return void else break catch instanceof with throw case default try this switch continue typeof delete let yield const",literal:"true false null undefined NaN Infinity"},c:[a.ASM,a.QSM,a.CLCM,a.CBLCLM,a.CNM,{b:"("+a.RSR+"|\\b(case|return|throw)\\b)\\s*",k:"return throw case",c:[a.CLCM,a.CBLCLM,{cN:"regexp",b:"/",e:"/[gim]*",i:"\\n",c:[{b:"\\\\/"}]},{b:"<",e:">;",sL:"xml"}],r:0},{cN:"function",bWK:true,e:"{",k:"function",c:[{cN:"title",b:"[A-Za-z$_][0-9A-Za-z$_]*"},{cN:"params",b:"\\(",e:"\\)",c:[a.CLCM,a.CBLCLM],i:"[\"'\\(]"}],i:"\\[|%"}]}}(hljs);hljs.LANGUAGES.css=function(a){var b={cN:"function",b:a.IR+"\\(",e:"\\)",c:[a.NM,a.ASM,a.QSM]};return{cI:true,i:"[=/|']",c:[a.CBLCLM,{cN:"id",b:"\\#[A-Za-z0-9_-]+"},{cN:"class",b:"\\.[A-Za-z0-9_-]+",r:0},{cN:"attr_selector",b:"\\[",e:"\\]",i:"$"},{cN:"pseudo",b:":(:)?[a-zA-Z0-9\\_\\-\\+\\(\\)\\\"\\']+"},{cN:"at_rule",b:"@(font-face|page)",l:"[a-z-]+",k:"font-face page"},{cN:"at_rule",b:"@",e:"[{;]",eE:true,k:"import page media charset",c:[b,a.ASM,a.QSM,a.NM]},{cN:"tag",b:a.IR,r:0},{cN:"rules",b:"{",e:"}",i:"[^\\s]",r:0,c:[a.CBLCLM,{cN:"rule",b:"[^\\s]",rB:true,e:";",eW:true,c:[{cN:"attribute",b:"[A-Z\\_\\.\\-]+",e:":",eE:true,i:"[^\\s]",starts:{cN:"value",eW:true,eE:true,c:[b,a.NM,a.QSM,a.ASM,a.CBLCLM,{cN:"hexcolor",b:"\\#[0-9A-F]+"},{cN:"important",b:"!important"}]}}]}]}]}}(hljs);hljs.LANGUAGES.xml=function(a){var c="[A-Za-z0-9\\._:-]+";var b={eW:true,c:[{cN:"attribute",b:c,r:0},{b:'="',rB:true,e:'"',c:[{cN:"value",b:'"',eW:true}]},{b:"='",rB:true,e:"'",c:[{cN:"value",b:"'",eW:true}]},{b:"=",c:[{cN:"value",b:"[^\\s/>]+"}]}]};return{cI:true,c:[{cN:"pi",b:"<\\?",e:"\\?>",r:10},{cN:"doctype",b:"<!DOCTYPE",e:">",r:10,c:[{b:"\\[",e:"\\]"}]},{cN:"comment",b:"<!--",e:"-->",r:10},{cN:"cdata",b:"<\\!\\[CDATA\\[",e:"\\]\\]>",r:10},{cN:"tag",b:"<style(?=\\s|>|$)",e:">",k:{title:"style"},c:[b],starts:{e:"</style>",rE:true,sL:"css"}},{cN:"tag",b:"<script(?=\\s|>|$)",e:">",k:{title:"script"},c:[b],starts:{e:"<\/script>",rE:true,sL:"javascript"}},{b:"<%",e:"%>",sL:"vbscript"},{cN:"tag",b:"</?",e:"/?>",c:[{cN:"title",b:"[^ />]+"},b]}]}}(hljs);hljs.LANGUAGES.python=function(a){var f={cN:"prompt",b:"^(>>>|\\.\\.\\.) "};var c=[{cN:"string",b:"(u|b)?r?'''",e:"'''",c:[f],r:10},{cN:"string",b:'(u|b)?r?"""',e:'"""',c:[f],r:10},{cN:"string",b:"(u|r|ur)'",e:"'",c:[a.BE],r:10},{cN:"string",b:'(u|r|ur)"',e:'"',c:[a.BE],r:10},{cN:"string",b:"(b|br)'",e:"'",c:[a.BE]},{cN:"string",b:'(b|br)"',e:'"',c:[a.BE]}].concat([a.ASM,a.QSM]);var e={cN:"title",b:a.UIR};var d={cN:"params",b:"\\(",e:"\\)",c:["self",a.CNM,f].concat(c)};var b={bWK:true,e:":",i:"[${=;\\n]",c:[e,d],r:10};return{k:{keyword:"and elif is global as in if from raise for except finally print import pass return exec else break not with class assert yield try while continue del or def lambda nonlocal|10",built_in:"None True False Ellipsis NotImplemented"},i:"(</|->|\\?)",c:c.concat([f,a.HCM,a.inherit(b,{cN:"function",k:"def"}),a.inherit(b,{cN:"class",k:"class"}),a.CNM,{cN:"decorator",b:"@",e:"$"},{b:"\\b(print|exec)\\("}])}}(hljs);</script>


<!--

Displays YUIDoc formatted source documentation scraped from input urls.

@class core-doc-viewer
-->

<polymer-element name="core-doc-viewer" attributes="url href sources" assetpath="../core-doc-viewer/">

<!--

Set url to add documentation from that location to the view.

@attribute url
@type String
-->

  <template>

    <context-free-parser url="{{url}}" on-data-ready="{{parserDataReady}}"></context-free-parser>

    <template repeat="{{sources}}">
      <context-free-parser url="{{}}" on-data-ready="{{parserDataReady}}"></context-free-parser>
    </template>

    <style>/*

Original style from softwaremaniacs.org (c) Ivan Sagalaev <Maniac@SoftwareManiacs.Org>

*/

pre code {
  display: block; padding: 0.5em;
  background: #F0F0F0;
}

pre code,
pre .subst,
pre .tag .title,
pre .lisp .title,
pre .clojure .built_in,
pre .nginx .title {
  color: black;
}

pre .string,
pre .title,
pre .constant,
pre .parent,
pre .tag .value,
pre .rules .value,
pre .rules .value .number,
pre .preprocessor,
pre .ruby .symbol,
pre .ruby .symbol .string,
pre .aggregate,
pre .template_tag,
pre .django .variable,
pre .smalltalk .class,
pre .addition,
pre .flow,
pre .stream,
pre .bash .variable,
pre .apache .tag,
pre .apache .cbracket,
pre .tex .command,
pre .tex .special,
pre .erlang_repl .function_or_atom,
pre .markdown .header {
  color: #800;
}

pre .comment,
pre .annotation,
pre .template_comment,
pre .diff .header,
pre .chunk,
pre .markdown .blockquote {
  color: #888;
}

pre .number,
pre .date,
pre .regexp,
pre .literal,
pre .smalltalk .symbol,
pre .smalltalk .char,
pre .go .constant,
pre .change,
pre .markdown .bullet,
pre .markdown .link_url {
  color: #080;
}

pre .label,
pre .javadoc,
pre .ruby .string,
pre .decorator,
pre .filter .argument,
pre .localvars,
pre .array,
pre .attr_selector,
pre .important,
pre .pseudo,
pre .pi,
pre .doctype,
pre .deletion,
pre .envvar,
pre .shebang,
pre .apache .sqbracket,
pre .nginx .built_in,
pre .tex .formula,
pre .erlang_repl .reserved,
pre .prompt,
pre .markdown .link_label,
pre .vhdl .attribute,
pre .clojure .attribute,
pre .coffeescript .property {
  color: #88F
}

pre .keyword,
pre .id,
pre .phpdoc,
pre .title,
pre .built_in,
pre .aggregate,
pre .css .tag,
pre .javadoctag,
pre .phpdoc,
pre .yardoctag,
pre .smalltalk .class,
pre .winutils,
pre .bash .variable,
pre .apache .tag,
pre .go .typename,
pre .tex .command,
pre .markdown .strong,
pre .request,
pre .status {
  font-weight: bold;
}

pre .markdown .emphasis {
  font-style: italic;
}

pre .nginx .built_in {
  font-weight: normal;
}

pre .coffeescript .javascript,
pre .javascript .xml,
pre .tex .formula,
pre .xml .javascript,
pre .xml .vbscript,
pre .xml .css,
pre .xml .cdata {
  opacity: 0.5;
}
</style>
    <style>:host {
  display: block;
  /*height: 100%;*/
}

div {
  display: block;
}

.element {
  font-size: 21px;
}

.name {
  /* typography */
  color: white;
  /* font-size: 14px; */
  font-size: 12px;
  font-weight: bold;
  text-decoration: none;
  /* colors / effects */
  background-color: #999;
  box-shadow: 0 1px 2px 0px rgba(0, 0, 0, 0.1);
  box-shadow: 0 0 1px 0 rgba(0, 0, 0, 0.1);
  border-radius: 2px;
  cursor: pointer;
  /* metrics */
  display: inline-block;
  padding: 4px 12px 5px 12px;
  margin: 4px 0;
  /*padding: 0.35em 1em;
  margin: 0.3em 0;*/
}

.method {
  background-color: #0F9D58;
}

.event {
  background-color: #F4B400;
}

.nattribute {
  background-color: #4285F4;
  border-radius: 2px 0 0 2px;
}

.type {
  background-color: white;
  border: 1px solid #4285F4;
  color: #4285F4;
  font-weight: bold;
  border-radius: 0 2px 2px 0;
  padding-top: 3px;
  padding-bottom: 4px;
}

.header {
  border: 1px solid rgba(0, 0, 0, 0.1);
  border-left: none;
  border-right: none;
  padding: 0 16px;
  line-height: 75px;
}

.ntitle {
  font-size: 13px;
  font-weight: bold;
  margin: 8px 0;
}

.box {
  margin-bottom: 40px;
}

pre code {
  font-size: 14px;
  padding: 12px 13px;
  max-width: 800px;
  white-space: pre-wrap;
  overflow: hidden;
}

a {
  color: #666;
  text-decoration: none;
}

.summary {
  width: 240px; 
  padding: 16px;
}

@media (max-width: 900px) {
  .summary {
    display: none;
  }
}

#menu {
  width: 280px;
}

#docs {
  overflow-x: auto;
  background-color: white;
}

#docsInner {
  min-width: 500px;
}

#fixed {
  position: fixed;
  opacity: 0.95;
  right: 24px;
  left: 296px;
  background-color: white;
  z-index: 1000;
  display: none;
}

.animate {
  -webkit-transition-property: left, top, width, height;
  -webkit-transition-duration: 0.3s;
  -webkit-transition-timing-function: ease-out;
}
</style>

    <polymer-grid-layout id="grid" on-polymer-grid-layout="{{gridLayout}}"></polymer-grid-layout>

    <div id="navigation" offscreen="basement" style="overflow-y: scroll;">

      <polymer-ui-menu selected="0" id="menu">

        <template repeat="{{classes}}">
          <polymer-ui-menu-item><a href="#{{name}}">{{name}}</a></polymer-ui-menu-item>
        </template>

      </polymer-ui-menu>

    </div>

    <div id="docs" flex="" on-marked-js-highlight="{{hilight}}" on-scroll="{{docsScroll}}">
      <div id="docsInner" flex="">

        <div id="fixed">
          <div class="header">

            <polymer-ui-icon-button icon="menu" on-tap="{{toggleNav}}" active="{{navOpen}}"></polymer-ui-icon-button>
            &nbsp;<span id="fixedTopic" class="element"></span>

          </div>
        </div>

        <template repeat="{{class in classes}}">

          <a id="{{class.name}}" class="element"></a>

          <div class="header topic">
            <polymer-ui-icon-button on-tap="{{toggleLayout}}" icon="menu" style="visibility: hidden;"></polymer-ui-icon-button>
            &nbsp;<span class="element">{{class.name}}</span>
          </div>
  
          <div>
            <polymer-flex-layout></polymer-flex-layout>

            <div class="summary">

              <template if="{{class.methods.length}}">
                <section class="box">
                  <div class="ntitle">Methods</div>
                  <template repeat="{{class.methods}}">
                    <span class="name method">{{name}}</span><br>
                  </template>
                </section>
              </template>

              <template if="{{class.attributes.length}}">
                <section class="box">
                  <div class="ntitle">Attributes</div>
                  <template repeat="{{class.attributes}}">
                    <span class="name nattribute">{{name}}</span><br>
                  </template>
                </section>
              </template>

              <template if="{{class.events.length}}">
                <section class="box">
                  <div class="ntitle">Events</div>
                  <template repeat="{{class.events}}">
                    <span class="name event">{{name}}</span><br>
                  </template>
                </section>
              </template>

            </div>

            <div flex="">
              <div style="padding: 16px;">

                <template if="{{class.description}}">
                  <section class="box">
                    <div class="ntitle">Description</div>
                    <marked-js text="{{class.description}}"></marked-js>
                  </section>
                </template>

                <template if="{{class.methods.length}}">
                  <section class="box">
                    <div class="ntitle">Methods</div>
                    <template repeat="{{class.methods}}">
                      <span class="name method">{{name}}</span>
                      <marked-js text="{{description}}"></marked-js>
                    </template>
                  </section>
                </template>

                <template if="{{class.attributes.length}}">
                  <section class="box">
                    <div class="ntitle">Attributes</div>
                    <template repeat="{{class.attributes}}">
                      <span class="name nattribute">{{name}}</span><span class="name type">{{type}}</span>
                      <marked-js text="{{description}}"></marked-js>
                      <br>
                    </template>
                  </section>
                </template>

                <template if="{{class.events.length}}">
                  <section class="box">
                    <div class="ntitle">Events</div>
                    <template repeat="{{class.events}}">
                      <span class="name event">{{name}}</span>
                      <marked-js text="{{description}}"></marked-js>
                      <br>
                    </template>
                  </section>
                </template>

              </div>
            </div>
          </div>
        </template>

        <hr>
        <div style="height: 1024px"></div>

      </div>
    </div>

  </template>
  <script>

    Polymer('core-doc-viewer', {
      sources: [],
      data: null,
      route: '',
      layouts: {
        open: [
          [1, 2, 2]
        ],
        closed: [
          [2, 2]
        ],
      },
      navOpen: true,
      ready: function() {
        this.classes = [];
        // TODO(sjmiles): manual because flatiron-director didn't work, find out why
        window.addEventListener('hashchange', this.parseLocationHash.bind(this));
        // TODO(sjmiles): improve method of configuring grid
        this.$.grid.nodes = [this.$.navigation, this.$.docs];
        this.$.grid.layout = this.layouts.open;
        //this.onMutation(this.$.docs, this.docsNodeChanged);
        // TODO(sjmiles): start observing DOM
        this.docsNodeChanged();
      },
      attached: function() {
        this.parseLocationHash();
      },
      parseLocationHash: function() {
        this.route = window.location.hash.slice(1);
      },
      routeChanged: function() {
        var anchor = this.shadowRoot.querySelector('a[id="' + this.route + '"]');
        if (anchor) {
          anchor.scrollIntoView();
        }
      },
      toggleNav: function(event, detail, sender) {
        this.navOpen = !this.navOpen;
      },
      navOpenChanged: function() {
        this.effectLayout();
      },
      effectLayout: function() {
        this.$.grid.layout = this.navOpen ? this.layouts.open : this.layouts.closed;
        this.$.fixed.style.left = this.navOpen ? this.fixedLeft + 'px' : '0px';
      },
      gridLayout: function() {
        // TODO(sjmiles): the 'fixed' header bar is relative to the screen
        // to position it dynamically we need to know offsetLeft of the
        // docs panel after the first layout.
        if (!this.fixedLeft) {
          this.fixedLeft = this.$.docs.offsetLeft;
          this.$.fixed.style.display = 'block';
          this.effectLayout();
        }
        this.$.docs.classList.add('animate');
        this.$.fixed.classList.add('animate');
      },
      hilight: function(event, detail, sender) {
        detail.code = hljs.highlightAuto(detail.code).value;
      },
      docsNodeChanged: function(observer) {
        this.$.docs.scrollTop = 0;
        this.docsScroll();
        this.onMutation(this.$.docs, this.docsNodeChanged);
      },
      docsScroll: function() {
        var t = this.$.docs.scrollTop + 80;
        var hcs = this.$.docsInner.querySelectorAll('.topic');
        for (var i = 0, hc; hc = hcs[i]; i++) {
          if (t >= hc.offsetTop && (!hcs[i+1] || t < hcs[i+1].offsetTop)) {
            var h = hc.querySelector('.element');
            if (h) {
              this.$.fixedTopic.innerText = h.innerText;	
            }
            return;
          }
        }
      },
      parserDataReady: function(event) {
        this.assimilateData(event.target.data);
      },
      dataChanged: function() {
        this.assimilateData(this.data);
      },
      assimilateData: function(data) {
        this.classes = this.classes.concat(data.classes);
        this.classes.sort(function(a, b) {
          var na = a.name.toLowerCase(), nb = b.name.toLowerCase();
          return (na < nb) ? -1 : (na == nb) ? 0 : 1;
        });
      }
    });

  </script>

</polymer-element>

<!--
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<style>
  body {
    margin: 0;
  }
</style>



<!--

Implements the default home-page for Polymer components.

`<core-component-page>` can render a default information page for any component.
Polymer components use this component in `index.html` to provide a common landing page.

`<core-component-page>` is _vulcanized_, which means it contains all it's dependencies baked in.
Therefore, this component is intended to be used only by itself in a page.

This *-dev package contains the raw source and the dependency manifest necessary
to reconstruct `core-component-page\core-component-page.html` via vulcanize.

`<core-component-page>` will set the page title automatically.

@group Polymer Core Elements
@element core-component-page

-->

<polymer-element name="core-component-page" attributes="moduleName sources" assetpath="../core-component-page-dev/">

  <template>

    <style>/*
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

:host {
  position: relative;
  display: block;
  font-family: Arial, sans-serif;
  height: 100vh;
}

h2 {
  display: inline-block;
  margin: 8px 6px;
  vertical-align: middle;
}

.choiceB, .choiceC, .choiceD {
  /* typography */
  color: white;
  /* font-size: 14px; */
  font-size: 12px;
  font-weight: bold;
  text-decoration: none;
  /* colors / effects */
  background-color: #4285F4;
  box-shadow: 0 1px 2px 0px rgba(0, 0, 0, 0.1);
  box-shadow: 0 0 1px 0 rgba(0, 0, 0, 0.1);
  border-radius: 2px;
  cursor: pointer;
  /* metrics */
  display: inline-block;
  padding: 4px 12px 5px 12px;
  margin: 4px 0;
}

core-doc-viewer {
  display: block;
  position: absolute;
  top: 50px;
  right: 0;
  bottom: 0px;
  left: 0;
  border: 1px solid silver;
}
</style>

    <h2>{{moduleName}}</h2>

    <a class="choiceC" target="_blank" href="../{{moduleName}}/demo.html">demo</a>

    <core-doc-viewer url="{{url}}" sources="{{sources}}"></core-doc-viewer>

  </template>

  <script>

    Polymer('core-component-page', {

      moduleName: '',
      // TODO(sjmiles): needed this to force Object type for deserialization
      sources: [],

      ready: function() {
        this.moduleName = this.moduleName || this.findModuleName();
      },

      moduleNameChanged: function() {
        document.title = this.moduleName;
        this.url = !this.sources.length && this.moduleName ? this.moduleName + '.html' : '';
      },

      findModuleName: function() {
        var path = location.pathname.split('/');
        var name = path.pop() || path.pop();
        if (name.indexOf('.html') >= 0) {
          name = path.pop();
        }
        return name || '';
      }

    });

  </script>

</polymer-element>
